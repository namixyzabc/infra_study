
### 1. バッチファイルとは？

バッチファイルとは、**Windowsのコマンドプロンプトで実行できる一連の命令（コマンド）を、順番に記述したテキストファイル**のことです。拡張子は `.bat` または `.cmd` が使われます。

通常、コマンドプロンプトでは一行ずつコマンドを打ち込んで実行しますが、バッチファイルを使えば、それらの連続した処理をファイルにまとめて保存し、ダブルクリックするだけで自動的に実行できます。

**主なメリット:**
*   **作業の自動化**: ファイルのバックアップ、名前の一括変更、ソフトウェアのインストールなど、毎回同じ手順で行う定型作業を自動化できます。
*   **効率化**: 複雑なコマンド操作を一度ファイルに書いておけば、誰でも簡単に同じ処理を再現できます。
*   **単純化**: 長いコマンドや複数のコマンドを一つのファイルにまとめることで、実行する処理を単純化できます。

---

### 2. 準備：バッチファイル作成の基本

バッチファイルの作成は非常に簡単です。

#### 必要なツール
特別な開発環境は必要ありません。Windowsに標準で付属している**「メモ帳」などのテキストエディタ**があれば作成できます。もちろん、Visual Studio Codeなどの高機能なエディタを使っても構いません。

#### 作成と実行の流れ
1.  **コマンドの記述**: テキストエディタを開き、実行したいコマンドを記述します。
2.  **名前を付けて保存**:
    *   「ファイル」メニューから「名前を付けて保存」を選択します。
    *   **ファイルの種類**を「すべてのファイル (\*.\*)」に変更します。
    *   ファイル名に「**任意の名前.bat**」と、必ず拡張子 `.bat` を付けて保存します。
    *   **文字コード**は「**ANSI**」または「**Shift_JIS**」で保存するのが基本です。日本語を含む場合はこの文字コードでないと文字化けの原因になります。
3.  **実行**:
    *   作成した `.bat` ファイルをダブルクリックします。
    *   または、コマンドプロンプトを開き、そのファイルのパスを指定して実行します。（例: `C:\Users\YourUser\Desktop\test.bat`）

---

### 3. 基本的なコマンド

まずは、バッチファイルの基本となる最もよく使われるコマンドを覚えましょう。

#### `@echo off`：おまじない
バッチファイルを実行すると、通常は実行されるコマンドそのものが一行ずつ画面に表示されます。これを非表示にし、実行結果だけをすっきりと見せるためのおまじないです。
**バッチファイルの先頭には、まずこれを書く**と覚えておきましょう。`@`を付けると、`echo off`というコマンド自体の表示も消えます。

```bat
@echo off

rem この下の行から処理が始まる
echo Hello, World!
```

#### `echo`：文字列の表示
画面に指定した文字列や変数の内容を表示します。デバッグ目的で変数の値を確認したり、ユーザーにメッセージを伝えたりする際に使います。

```bat
@echo off

echo これはメッセージです。
echo.
echo ↑ echo. と書くと改行（空白行）を挿入できます。
```

#### `rem` と `::`：コメント
プログラムの動作に影響しない注釈（コメント）を記述するためのコマンドです。処理内容をメモしておくことで、後から見返したときに分かりやすくなります。
`rem` と `::` のどちらも使えますが、`::` の方が処理速度が若干速いとされています。

```bat
@echo off

rem これはremを使ったコメントです。
:: こちらはコロンを2つ使ったコメントです。どちらも処理はされません。

echo コメントは画面に表示されません。
```

#### `pause`：一時停止
処理を一時停止し、「続行するには何かキーを押してください...」というメッセージを表示します。
バッチファイルの処理が一瞬で終わってしまうと、結果を確認する前にウィンドウが閉じてしまいます。`pause`を最後に入れておくことで、実行結果を目で見て確認できます。

```bat.
@echo off
echo 処理が完了しました。
pause
```

#### `cls`：画面クリア
コマンドプロンプトの画面に表示されている内容をすべて消去し、画面をきれいにします。

```bat
@echo off
echo このメッセージは…
pause
cls
echo …すぐに消えます。
pause
```

#### `title`：ウィンドウタイトルの変更
コマンドプロンプトのウィンドウのタイトルバーに表示されるテキストを変更します。何の処理をしているバッチファイルなのかを示すのに便利です。

```bat
@echo off
title バックアップ実行中...
echo バックアップ処理を行っています。
pause```

#### `exit`：バッチファイルの終了
バッチファイルの処理を途中で終了します。サブルーチン内で使用する場合は、`/b` オプションを付けて `exit /b` とすることで、サブルーチンだけを抜け、呼び出し元の処理に戻ることができます。

---

### 4. 変数

バッチファイルでは、`set` コマンドを使って一時的にデータを保存しておくための「変数」を利用できます。

#### 変数の宣言と代入：`set`
`set 変数名=値` の形式で、変数に値を代入します。**等号（=）の前後にスペースを入れてはいけません。**

```bat
@echo off

set USER_NAME=Taro
set FILE_PATH=C:\Users\Public\Documents
```

#### 変数の利用：`%変数名%`
代入した値を利用するには、変数名を `%%` で囲みます。

```bat
@echo off
set USER_NAME=Taro
echo こんにちは、%USER_NAME% さん。

set FILE_PATH=C:\data\sample.txt
echo 対象ファイル: %FILE_PATH%
pause
```

#### ユーザーからの入力を受け取る：`set /p`
`/p` オプションを付けることで、ユーザーがキーボードから入力した値を変数に格納できます。

```bat
@echo off
set /p INPUT_NAME=お名前を入力してください: 
echo こんにちは、%INPUT_NAME% さん！
pause
```

#### 簡単な計算：`set /a`
`/a` オプションを付けることで、簡単な四則演算ができます。

```bat
@echo off
set /a RESULT=10 + 5
echo 10 + 5 = %RESULT%

set VAL1=100
set VAL2=20
set /a VAL3=%VAL1% * %VAL2%
echo %VAL1% * %VAL2% = %VAL3%
pause
```

#### 特殊な変数（環境変数）
バッチファイルでは、システムによってあらかじめ定義されている特殊な変数が利用できます。これらは `set` で定義しなくても使えます。

| 変数名 | 内容 |
|:---|:---|
| `%date%` | 現在の日付 (例: 2025/07/31) |
| `%time%` | 現在の時刻 (例: 13:01:15.31) |
| `%cd%` | 現在の作業ディレクトリ（カレントディレクトリ）のパス |
| `%errorlevel%` | 直前に実行したコマンドの終了コード（成功すれば0、失敗すれば0以外） |
| `%random%` | 0から32767までのランダムな整数 |

**日付と時刻の整形**
`%date%` や `%time%` はそのままではファイル名として使いにくいため、以下のようにして整形することが多いです。

```bat
@echo off
rem 日付を YYYYMMDD 形式に整形
set TODAY=%date:/=%

rem 時刻を HHMMSS 形式に整形 (スペースが入る場合は置換)
set NOW=%time: =0%
set NOW=%NOW:~0,2%%NOW:~3,2%%NOW:~6,2%

echo 今日は %TODAY% です。
echo 今の時刻は %NOW% です。
pause
```
*   `%date:/=%`: `%date%` の中の `/` を空文字列に置換します。
*   `%NOW:~0,2%`: 変数 `NOW` の0文字目から2文字を切り出します。

---

### 5. 制御構文

処理の流れをコントロールするための構文です。これらを使いこなすことで、より複雑で実用的なバッチファイルが作成できます。

#### 条件分岐 (`if`)
指定した条件が真（正しい）か偽（間違い）かによって、処理を分岐させます。

*   **文字列の比較**
    `if "文字列1"=="文字列2" コマンド`

    ```bat
    @echo off
    set /p ANSWER=yesかnoで答えてください: 
    if "%ANSWER%"=="yes" echo 「はい」が選択されました。
    if "%ANSWER%"=="no" echo 「いいえ」が選択されました。
    pause
    ```
    ※変数を比較する際は、予期せぬエラーを防ぐため `"%変数%"` のようにダブルクォーテーションで囲むのが定石です。

*   **`if else` 構文**
    条件が真の場合と偽の場合で、それぞれ異なる処理を実行します。複数のコマンドを実行する場合は `()` で囲みます。

    ```bat
    @echo off
    set /p ANSWER=yesかnoで答えてください: 
    if /i "%ANSWER%"=="yes" (
        echo 「はい」の処理を実行します。
    ) else (
        echo 「はい」以外の処理を実行します。
    )
    pause
    ```
    ※`/i` オプションを付けると、大文字と小文字を区別せずに比較できます ("yes" と "YES" が同じと見なされる)。

*   **数値の比較**
    数値の比較には、以下の比較演算子を使います。

| 演算子 | 意味 |
|:---|:---|
| `EQU` | 等しい (Equal) |
| `NEQ` | 等しくない (Not Equal) |
| `LSS` | より小さい (Less Than) |
| `LEQ` | 以下 (Less than or Equal) |
| `GTR` | より大きい (Greater Than) |
| `GEQ` | 以上 (Greater than or Equal) |

    ```bat
    @echo off
    set /a SCORE=85
    if %SCORE% GEQ 80 (
        echo 合格です！
    ) else (
        echo 不合格です。
    )
    pause
    ```

*   **ファイルの存在確認**
    `if exist ファイル名 コマンド`

    ```bat
    @echo off
    if exist "C:\log.txt" (
        echo log.txt が見つかりました。
    ) else (
        echo log.txt は存在しません。
    )
    pause
    ```

*   **`errorlevel` の判定**
    コマンドが失敗したかどうかで処理を分岐できます。

    ```bat
    @echo off
    rem 存在しないファイルをコピーしようとして、わざとエラーを出す
    copy non_existent_file.txt C:\
    
    if errorlevel 1 (
        echo コマンドの実行に失敗しました。
    ) else (
        echo コマンドは正常に終了しました。
    )
    pause
    ```
    ※`if errorlevel 1` は、「errorlevelが1以上の場合」という意味になります。

#### 繰り返し (`for`)
指定した条件の間、同じ処理を繰り返します。バッチファイルの中でも特に強力なコマンドです。

**重要**: バッチファイル内で `for` を使う場合、ループ変数は `%%A` のように `%` を2つ重ねます。コマンドプロンプトで直接実行する場合は `%A` のように1つです。

*   **基本的なループ**
    `for %%変数 in (リスト) do コマンド`

    ```bat
    @echo off
    rem (月 火 水 木 金) のリストを順番に処理
    for %%d in (月 火 水 木 金) do (
        echo 今日は %%d 曜日です。
    )
    pause
    ```

*   **数値のループ (`/L`)**
    `for /L %%変数 in (開始, ステップ, 終了) do コマンド`

    ```bat
    @echo off
    rem 1から5まで1ずつ増やしながらループ
    for /L %%i in (1, 1, 5) do (
        echo カウント: %%i
    )
    pause
    ```

*   **ファイルに対するループ**
    指定したフォルダ内のファイルに対して、一つずつ処理を実行します。ワイルドカード `*` が使えます。

    ```bat
    @echo off
    rem C:\log フォルダ内の全ての.txtファイルに対してループ
    for %%f in (C:\log\*.txt) do (
        echo ファイル名: %%f
        echo 更新日時: %%~tf
    )
    pause
    ```
    ※`%%~tf` のように、ループ変数に `~t` などの修飾子を付けることで、ファイルの更新日時やサイズなどを取得できます。

*   **ファイルの内容やコマンド結果を処理 (`/F`)**
    `for /F` は最も強力で、少し複雑なオプションを持ちます。ファイルの中身を一行ずつ読み込んだり、コマンドの実行結果を処理したりできます。

    **構文**: `for /F ["オプション"] %%変数 in (処理対象) do コマンド`

    **処理対象**:
    *   `('コマンド')`: コマンドの実行結果
    *   `("文字列")`: ダブルクォーテーションで囲まれた文字列
    *   `(ファイル名)`: テキストファイル

    **主なオプション**:
    *   `"delims=,"`: 区切り文字を指定します。この例ではカンマ。
    *   `"tokens=1,2,*"`: 区切り文字で分割した後、何番目の要素を取り出すかを指定します。`*` は残り全部を意味します。

    **例1: ファイルの内容を1行ずつ読み込む**
    `userlist.txt` の中身:
    ```
    Taro,Tokyo
    Jiro,Osaka
    Saburo,Fukuoka
    ```

    バッチファイル:
    ```bat
    @echo off
    rem userlist.txt を読み込み、カンマで分割して1番目と2番目の要素を取得
    for /F "tokens=1,2 delims=," %%a in (userlist.txt) do (
        echo 名前: %%a, 出身地: %%b
    )
    pause
    ```
    実行結果:
    ```
    名前: Taro, 出身地: Tokyo
    名前: Jiro, 出身地: Osaka
    名前: Saburo, 出身地: Fukuoka
    ```

    **例2: コマンドの実行結果を処理**
    ```bat
    @echo off
    rem `dir /b` (ファイル名だけを一覧表示) の結果を1行ずつ処理
    for /F %%f in ('dir /b *.log') do (
        echo ログファイルが見つかりました: %%f
    )
    pause
    ```

#### ジャンプ (`goto`)
`goto ラベル名` で、指定した `:ラベル名` の行まで処理をジャンプさせます。
単純な処理分岐や、エラー発生時に終了処理へ飛ばす際などに使われます。ただし、多用すると処理の流れが追いにくくなる（スパゲッティコード）ため、注意が必要です。

```bat
@echo off
:MENU
cls
echo 1. 処理Aを実行
echo 2. 処理Bを実行
echo 3. 終了
set /p SELECT=番号を選択してください: 

if "%SELECT%"=="1" goto PROCESS_A
if "%SELECT%"=="2" goto PROCESS_B
if "%SELECT%"=="3" goto END

echo 無効な番号です。
pause
goto MENU

:PROCESS_A
echo 処理Aを実行しました。
pause
goto MENU

:PROCESS_B
echo 処理Bを実行しました。
pause
goto MENU

:END
echo 終了します。
pause
```

---

### 6. ファイル・ディレクトリ操作

バッチファイルの得意分野である、ファイルやディレクトリの操作に関するコマンドです。

| コマンド | 内容 |
|:---|:---|
| `cd` | ディレクトリの移動 |
| `md` or `mkdir` | ディレクトリの作成 |
| `rd` or `rmdir` | （空の）ディレクトリの削除。`/S` で中身ごと、`/Q` で確認なしに削除 |
| `copy` | ファイルのコピー |
| `move` | ファイルやディレクトリの移動、名前の変更 |
| `del` or `erase` | ファイルの削除 |
| `ren` or `rename` | ファイルやディレクトリの名前の変更 |
| `type` | テキストファイルの内容を表示 |
| `xcopy` | 高機能なファイル・ディレクトリのコピー（サブディレクトリも対象にできる） |
| `robocopy` | `xcopy` よりさらに高機能で堅牢なコピーコマンド（バックアップなどに最適） |

**例：`robocopy` を使ったバックアップ**
`D:\backup` フォルダに、`C:\work` フォルダの内容を、サブディレクトリも含めてミラーリング（同期）コピーする。

```bat
@echo off
title バックアップ実行中
echo C:\work の内容を D:\backup にバックアップします。

rem /MIR : ミラーリング（コピー元にないファイルはコピー先から削除）
rem /R:3 : リトライ回数を3回に設定
rem /W:5 : リトライ間隔を5秒に設定
robocopy "C:\work" "D:\backup" /MIR /R:3 /W:5

echo バックアップが完了しました。
pause
```

#### リダイレクトとパイプ
コマンドの入出力を制御することで、より柔軟な処理が可能になります。

*   `>` (リダイレクト): コマンドの実行結果をファイルに**上書き**保存します。
    `dir > filelist.txt`
*   `>>` (リダイレクト): コマンドの実行結果をファイルに**追記**保存します。
    `echo 処理完了: %date% %time% >> log.txt`
*   `<` (リダイレクト): ファイルの内容をコマンドの入力として使います。
*   `|` (パイプ): あるコマンドの実行結果を、次のコマンドの入力として渡します。
    `dir /b | find ".txt"` (dirの結果から、".txt" を含む行だけを検索)
*   `2>` (エラー出力のリダイレクト): エラーメッセージだけをファイルに保存します。
    `dir non_existent_folder 2> error.log`

---

### 7. サブルーチン（関数のようなもの）

`call` コマンドを使うことで、バッチファイル内で特定の処理を部品化（サブルーチン化）し、何度も呼び出すことができます。

*   **サブルーチンの定義**: `:ラベル名` で始まり、`exit /b` で終わる一連の処理ブロックです。`exit /b` はサブルーチンを終了し、呼び出し元に戻る命令です。
*   **サブルーチンの呼び出し**: `call :ラベル名 引数1 引数2 ...`
*   **引数の受け取り**: サブルーチン内では、渡された引数を `%1`, `%2`, ... で受け取ります。`%*` ですべての引数をまとめて受け取れます。

```bat
@echo off
echo メイン処理を開始します。

rem サブルーチン "Sub" を引数 "Taro" と "25" で呼び出す
call :Sub Taro 25

rem サブルーチン "Sub" を引数 "Hanako" と "30" で呼び出す
call :Sub Hanako 30

echo メイン処理を終了します。
pause
goto :EOF

rem --- ここからサブルーチン ---
:Sub
echo.
echo === サブルーチン内です ===
set NAME=%1
set AGE=%2
echo 受け取った名前: %NAME%
echo 受け取った年齢: %AGE%
echo ========================
exit /b
rem --- サブルーチンここまで ---
```
`goto :EOF` は、ファイルの終端へジャンプするという意味で、メイン処理が終わった後に誤ってサブルーチンが実行されるのを防ぎます。

---

### 8. 実践的なスクリプト例

#### 例1：日付フォルダ付きバックアップスクリプト
デスクトップの `Source` フォルダを、バックアップ先の `Backup` フォルダに、`YYYYMMDD_HHMMSS` という名前のフォルダを作成してコピーします。

```bat
@echo off
setlocal

rem --- 設定項目 ---
set SRC_DIR=%USERPROFILE%\Desktop\Source
set DST_DIR=%USERPROFILE%\Desktop\Backup
rem ----------------

echo バックアップ元: %SRC_DIR%
echo バックアップ先: %DST_DIR%
echo.

rem 日付と時刻の整形
set YYYYMMDD=%date:/=%
set HHMMSS=%time: =0%
set HHMMSS=%HHMMSS:~0,2%%HHMMSS:~3,2%%HHMMSS:~6,2%
set TIMESTAMP=%YYYYMMDD%_%HHMMSS%

set DST_PATH=%DST_DIR%\%TIMESTAMP%

echo %DST_PATH% を作成してバックアップします...
robocopy "%SRC_DIR%" "%DST_PATH%" /E /R:3 /W:5

if errorlevel 8 (
    echo バックアップは正常に完了しました（一部スキップされたファイルあり）。
) else if errorlevel 1 (
    echo バックアップに失敗しました。
) else (
    echo バックアップが正常に完了しました。
)

pause
endlocal
```

#### 例2：ファイル名一括変更スクリプト
指定したフォルダ内のすべての `.txt` ファイルの拡張子を `.log` に変更します。

```bat
@echo off
setlocal

rem --- 設定項目 ---
set TARGET_DIR=C:\target_folder
rem ----------------

if not exist "%TARGET_DIR%" (
    echo フォルダが見つかりません: %TARGET_DIR%
    pause
    exit /b
)

cd /d "%TARGET_DIR%"

echo %TARGET_DIR% 内の .txt ファイルを .log に変更します。
for %%f in (*.txt) do (
    ren "%%f" "%%~nf.log"
    echo %%f  --->  %%~nf.log
)

echo 処理が完了しました。
pause
endlocal
```*   `cd /d "%TARGET_DIR%"`: `/d` オプションでドライブが違っても移動できます。
*   `%%~nf`: ループ変数 `%%f` から、拡張子を除いたファイル名だけを取得します。

---

### 9. 高度なトピックと注意点

#### 遅延環境変数
`for` ループの中で `set` コマンドを使って変数の値を変更しても、ループ内ではその変更がうまく反映されない、という問題があります。

```bat
@echo off
setlocal

set COUNT=0
for /L %%i in (1, 1, 5) do (
    set /a COUNT=%COUNT% + 1
    echo %COUNT%  <-- これはずっと 0 のまま表示される
)
echo 最終結果: %COUNT% <-- ここでは 5 になっている
pause
```

これは、`for` ループが始まる前に、ループブロック内の `%COUNT%` がすべて `0` という値に置き換えられてしまうために起こります。

この問題を解決するのが**遅延環境変数**です。
1.  ファイルの先頭あたりに `setlocal enabledelayedexpansion` を記述します。
2.  ループ内など、リアルタイムで値を取得したい変数を `%変数名%` の代わりに `!変数名!` で囲みます。

```bat
@echo off
setlocal enabledelayedexpansion

set COUNT=0
for /L %%i in (1, 1, 5) do (
    set /a COUNT=!COUNT! + 1
    echo !COUNT!  <-- これで 1, 2, 3, 4, 5 と表示される
)
echo 最終結果: !COUNT!
pause
endlocal
```

#### 文字コードの問題
バッチファイルは基本的に**Shift_JIS (ANSI)**で動作します。UTF-8で保存されたファイルを `type` コマンドで表示したり、`for /F` で読み込んだりすると文字化けします。
一時的にUTF-8を扱いたい場合は、コマンドプロンプトのコードページを変更する `chcp 65001` というコマンドを使いますが、副作用もあるため注意が必要です。基本はShift_JISで統一するのが無難です。

#### デバッグのヒント
スクリプトがうまく動かないときは、以下の方法を試してみてください。
*   `@echo off` を一時的に `@echo on` に変更するかコメントアウトし、どのコマンドが実行されているか確認する。
*   怪しい場所の前後で `pause` を実行し、処理を止めて状況を確認する。
*   `echo %変数名%` や `echo !変数名!` を挟んで、変数の値が意図通りか確認する。
*   複雑なコマンドは、まずコマンドプロンプトで直接一行ずつ実行して試してみる。

---

