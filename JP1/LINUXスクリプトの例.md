以下のように内容を整えました。

---

## JP1/AJS3の業務自動化の基本

JP1/AJS3（Automatic Job Management System 3）は、定型的・定期的な業務を自動化するための製品です。複雑な業務フローにも対応しており、業務を自動的に実行するためには、以下の2つの要素を定義する必要があります。

1.  **業務内容と実行順序**:
    一つ一つの作業を「ジョブ」として定義し、それらをまとめて実行順序を関連づけたものを「ジョブネット」として定義します。ジョブの最小単位は、コマンド、アプリケーションプログラム、シェルスクリプトなどです。
2.  **業務を実行するスケジュール、または業務の契機となる事象**:
    毎日、毎月といった決まったスケジュールに従って実行することも、ファイルの作成やイベントの発生などを契機として実行することも可能です。

JP1/AJS3は、マネージャーホストとエージェントホストの構成で、複数のホストにまたがる業務を一元的に管理できます。マネージャーホストは業務を管理し、エージェントホストは実際に業務（ジョブ）を実行します。

## ジョブの実行環境とユーザー管理

JP1/AJS3のジョブ実行において、ユーザー管理とアクセス権限の設定は非常に重要です。特に、Linux環境では、JP1ユーザーとOSユーザーのマッピングがジョブの実行権限に直結します。

### ユーザーマッピングの概念

「**ユーザーマッピング**」とは、処理の実行先ホスト上でJP1ユーザーとOSユーザーを対応づける操作のことです。JP1/AJS3では、ジョブを実行する際に、JP1ユーザーに対応づけられているOSユーザーの権限で実行ファイルなどのOS資源にアクセスし、処理を実行します。

*   **マネージャーホストでの設定**:
    マネージャーホストのJP1/Baseのセットアップでは、JP1専用のアカウントであるJP1ユーザーの登録、JP1ユーザーの操作権限の設定（JP1権限レベル）、そしてユーザーマッピングが実施されます。
*   **エージェントホストでの設定**:
    エージェントホストでも、マネージャーホストに登録したJP1ユーザーとエージェントホストのOSユーザーを対応づけて、JP1ユーザーがエージェントホストのOS資源にアクセスできるようにユーザーマッピングが必要です。
*   **設定手順 (CLI/GUI)**:
    ユーザーマッピングは、Windows環境ではJP1/Baseの環境設定ダイアログボックス（GUI）を通じて行われ、JP1ユーザー名、サーバーホスト名（実行要求元ホスト）、そしてマッピングするOSユーザーを指定します。Linux環境では、`jbsmkumap`コマンドとユーザーマッピング定義ファイルを編集することで設定できます。
*   **自動初期設定**:
    JP1/Baseを新規にインストールすると、`jp1admin`というJP1ユーザーが自動で初期設定され、OSユーザーの`root`にマッピングされます。このデフォルトユーザーを使って運用する場合は、JP1/Baseのセットアップは不要な場合があります。

### ジョブ実行時の権限

*   UNIX環境のジョブは、ユーザーマッピングで変換された実行OSユーザーのローカルログインスクリプトが読み込まれ、特に指定がない限り、その実行OSユーザーのログインシェルで実行されます。
*   PCジョブ、UNIXジョブ、HTTP接続ジョブでは、実行時に使用するOSユーザーを明示的に指定できます（「実行時のユーザー」）。このOSユーザーは、JP1ユーザー（登録ユーザーまたは所有ユーザー）にマッピングされている必要があります。
*   イベントジョブは、エージェントホストのJP1/AJS3を起動しているユーザー権限で実行されるため、「実行ユーザー種別」を指定しても無効です。

## 実務でよく使われる処理内容とJP1ユニットの連携

ここでは、Linux環境におけるJP1/AJS3での実務シナリオと、それに対応するJP1ジョブユニットの利用、およびスクリプトの概念的な役割について詳述します。

### 1. 定型的なバッチ処理の自動実行

多くのシステムでは、日次、月次、週次などの決まったタイミングで、データ集計、レポート作成、ファイル転送などのバッチ処理が実行されます。

*   **JP1ジョブユニット**:
    *   **UNIXジョブ**: Linux環境でシェルスクリプトや実行ファイルを直接実行するジョブです。最も基本的なジョブ単位となります。
    *   **ジョブネット**: 複数のUNIXジョブを実行順序に従って自動実行するために使用します。
    *   **スケジュール**: ジョブネットをいつ実行するかを定義します。特定の時刻や曜日、日付などを指定できます。

*   **スクリプトの概念と役割**:
    *   **目的**: データの入力、集計、帳票作成、プリンタ出力といった一連の業務処理を、定義された順序で実行すること。
    *   **処理内容**:
        *   **データの取得・加工**: 例えば、特定のディレクトリから最新の売上データを取得し、整形するシェルスクリプト (`get_sales_data.sh`)。
            ```bash
            #!/bin/bash
            SOURCE_DIR="/data/sales/raw"
            TARGET_DIR="/data/sales/processed"
            TIMESTAMP=$(date +"%Y%m%d%H%M%S")
            LOG_FILE="/var/log/my_batch/get_sales_${TIMESTAMP}.log"
            ERROR_LOG="/var/log/my_batch/get_sales_error_${TIMESTAMP}.log"

            mkdir -p "${TARGET_DIR}" "${LOG_FILE%/*}"

            if [ -f "${SOURCE_DIR}/daily_sales.csv" ]; then
              cp "${SOURCE_DIR}/daily_sales.csv" "${TARGET_DIR}/daily_sales_${TIMESTAMP}.csv" >> "${LOG_FILE}" 2>> "${ERROR_LOG}"
              if [ $? -eq 0 ]; then
                echo "Sales data copied successfully." >> "${LOG_FILE}"
                exit 0 # 正常終了
              else
                echo "Error copying sales data." >> "${ERROR_LOG}"
                exit 1 # 異常終了
              fi
            else
              echo "Source file daily_sales.csv not found." >> "${ERROR_LOG}"
              exit 2 # ファイル不在エラー
            fi
            ```
        *   **集計処理**: 加工されたデータを基に、別のスクリプトがデータベースを更新したり、レポートを生成したりします (`aggregate_data.sh`)。
            ```bash
            #!/bin/bash
            PROCESSED_FILE="/data/sales/processed/daily_sales_$(date +"%Y%m%d")*.csv"

            if [ -f "${PROCESSED_FILE}" ]; then
              /opt/my_app/bin/sales_aggregator -i "${PROCESSED_FILE}" -o "/data/sales/reports/daily_summary_$(date +"%Y%m%d").txt"
              if [ $? -eq 0 ]; then
                echo "Aggregation successful."
                exit 0
              else
                echo "Aggregation failed. Check application logs."
                exit 1
              fi
            else
              echo "Processed file not found for aggregation."
              exit 1
            fi
            ```
        *   **レポート配信**: 生成されたレポートを関係者にメールで送信したり、FTPで転送したりする処理 (`distribute_report.sh`)。
            ```bash
            #!/bin/bash
            REPORT_FILE="/data/sales/reports/daily_summary_$(date +"%Y%m%d").txt"

            if [ -f "${REPORT_FILE}" ]; then
              /usr/bin/mail -s "Daily Sales Summary" recipient@example.com < "${REPORT_FILE}"
              if [ $? -eq 0 ]; then
                echo "Report sent successfully."
                exit 0
              else
                echo "Failed to send report."
                exit 1
              fi
            else
              echo "Report file not found."
              exit 1
            fi
            ```
    *   **JP1/AJS3との連携**: スクリプトは、JP1/AJS3がジョブの成否を判断できるように、**適切な終了コード（リターンコード）**を返す必要があります。通常、`0`は正常終了、`0以外`は異常終了を示します。JP1/AJS3は、この終了コードに基づいて次のジョブの実行を制御したり、エラー通知を発行したりします。

### 2. イベント駆動型処理

決まった時刻ではなく、特定の事象が発生したことを契機に業務を開始したい場合に利用されます。

*   **JP1ジョブユニット**:
    *   **イベントジョブ**: 特定の事象（ファイル作成・更新・削除、JP1イベントの受信など）を監視し、その発生を検知するとジョブネットを開始します。Linux環境では、主に以下のジョブが利用されます。
        *   **ファイル監視ジョブ**: 指定したファイルが存在するかどうか、または更新されたかを監視します。
        *   **JP1イベント受信監視ジョブ**: JP1イベントサービスに登録されたJP1イベントを監視します。
        *   **ログファイル監視ジョブ**: ログファイルに特定の文字列が出力されたことを監視します。正規表現も利用可能です。
    *   **ジョブネット**: イベントジョブが検知した事象をトリガーとして、後続の業務処理を行うジョブネットが実行されます。

*   **スクリプトの概念と役割**:
    *   **目的**: 外部システムやユーザー操作によって発生する非定形なイベントに対応し、自動的に業務を開始すること。
    *   **処理内容**:
        *   **ファイル到着時の処理**: FTPでデータファイルが転送されてきたら、そのファイルを処理するジョブネットを開始する。
            *   *（ファイル監視ジョブの設定）*:
                監視対象ファイル名: `/incoming/data/*.csv`, 監視条件: 「ファイルが存在すれば正常」
            *   *（後続のUNIXジョブのスクリプト）*:
                ```bash
                #!/bin/bash
                for file in /incoming/data/*.csv; do
                  if [ -f "$file" ]; then
                    /opt/data_processor/process_csv.sh "$file"
                    if [ $? -eq 0 ]; then
                      mv "$file" /incoming/data/processed/
                    else
                      mv "$file" /incoming/data/failed/
                      exit 1 # 処理失敗
                    fi
                  fi
                done
                exit 0
                ```
        *   **システムログからの異常検知**: `/var/log/messages`に致命的なエラーが出力されたら、管理者へ緊急通知するジョブネットを開始する。
            *   *（ログファイル監視ジョブの設定）*:
                監視対象ログファイル名: `/var/log/messages`, 監視文字列: `CRITICAL_ERROR.*Failed` (正規表現)
            *   *（後続のアクションジョブ）*: JP1/AJS3のメール送信機能を利用するため、ユーザーが直接スクリプトを書く必要はありません。

*   **JP1/AJS3との連携**: イベントジョブの監視条件が成立すると、それがジョブネットの起動トリガーとなり後続ジョブが実行されます。スクリプトが`jevsend`コマンドで直接イベントを発生させることも可能です。

### 3. 条件分岐とエラーリカバリー

先行処理の結果に応じて処理を変えたり、エラー時に自動回復を試みたりすることが不可欠です。

*   **JP1ジョブユニット**:
    *   **判定ジョブ**: 先行ジョブの終了コードやファイルの有無に基づき、後続ジョブの実行を制御します。
    *   **リカバリージョブ**: 特定のジョブが異常終了した場合にのみ実行されるジョブを定義できます。
    *   **リトライ設定**: ジョブが異常終了した場合に、自動的に再実行を試みる設定です。

*   **スクリプトの概念と役割**:
    *   **目的**: 業務フローの柔軟性を高め、障害時の手動介入を最小限に抑えること。
    *   **処理内容**:
        *   **終了コードによる条件分岐**: データ処理が成功した場合と失敗した場合で、後続の処理を分岐させる。
            *   *（データ処理UNIXジョブのスクリプト）*:
                ```bash
                #!/bin/bash
                /opt/my_app/process_data.sh
                exit $? # 実行結果をそのままJP1に返す
                ```
            *   *（JP1/AJS3の設定）*: このジョブの後続に判定ジョブを配置し、終了コード`0`なら正常パス、`0以外`なら異常パスへ進むように設定します。
        *   **リカバリー処理**: 集計処理が失敗した場合、ログを収集して管理者に通知する。
            *   *（リカバリージョブとして設定するスクリプト）*:
                ```bash
                #!/bin/bash
                LOG_PATH="/var/log/my_batch/aggregation_error.log"
                cp /tmp/current_aggregation.log "${LOG_PATH}"
                echo "Aggregation failed. Log collected at ${LOG_PATH}. Sending notification..."
                /usr/bin/mail -s "CRITICAL: Aggregation Failed" admin@example.com < "${LOG_PATH}"
                exit 0 # リカバリー処理自体は正常終了
                ```
*   **JP1/AJS3との連携**: スクリプトが返す**正確な終了コード**が、判定ジョブやリカバリージョブの実行を決定する鍵となります。

### 4. ジョブ間のデータ連携

先行ジョブの出力情報を後続ジョブで利用し、動的に変化する情報を引き継ぐことができます。

*   **JP1ジョブユニット**:
    *   **引き継ぎ情報設定ジョブ**: 先行ジョブの標準出力から必要な情報を切り出し、後続ジョブに引き継ぎます。
    *   **マクロ変数**: 切り出された情報はマクロ変数として後続ジョブで使用されます。

*   **スクリプトの概念と役割**:
    *   **目的**: ジョブネット内の各ジョブが連携するために、動的に生成されるデータを共有すること。
    *   **処理内容**:
        1.  **先行ジョブの標準出力**: ファイルパスを生成し、標準出力に出力する。
            ```bash
            #!/bin/bash
            GENERATED_FILE_NAME="report_$(date +"%Y%m%d%H%M%S").txt"
            echo "/data/reports/${GENERATED_FILE_NAME}"
            exit 0
            ```
        2.  **引き継ぎ情報設定ジョブでの情報切り出し**: JP1/AJS3の定義で、先行ジョブの標準出力から文字列を抽出し、`$$FILE_PATH$$`のようなマクロ変数に設定します。
        3.  **後続ジョブでのマクロ変数利用**: 後続ジョブがマクロ変数を引数として利用する。
            ```bash
            #!/bin/bash
            REPORT_FILE="$$FILE_PATH$$"
            if [ -f "${REPORT_FILE}" ]; then
              /opt/my_app/generate_pdf_from_report.sh "${REPORT_FILE}"
              exit $?
            else
              echo "Report file ${REPORT_FILE} not found."
              exit 1
            fi
            ```
*   **JP1/AJS3との連携**: 先行ジョブは結果を標準出力し、引き継ぎ情報設定ジョブがそれを解析してマクロ変数に登録します。後続ジョブは展開されたマクロ変数を受け取って実行されます。
    > **Note:** 標準出力の引き継ぎサイズには制限（4,096バイト）があります。

### 5. 通知とレポート

ジョブの実行結果やシステムの状態を、関係者に自動的に通知します。

*   **JP1ジョブユニット**:
    *   **メール送信ジョブ**: ジョブの異常終了時などに、メールで通知します。
    *   **JP1イベント送信ジョブ**: JP1イベントをJP1/Baseのイベントサービスに登録し、JP1/IMなどで集中監視します。
    *   **JP1/Cm2状態通知ジョブ**: JP1/Cm2/NNMなどのネットワーク管理システムに状態を通知します。

*   **スクリプトの概念と役割**:
    *   **目的**: システムの状況変化をタイムリーに伝達し、問題の早期発見と対応を促すこと。
    *   **処理内容**: これらのジョブはJP1/AJS3の機能として提供されるため、通常、ユーザーがスクリプトを記述する必要はありません。宛先、件名、本文などをダイアログボックスで設定します。

*   **JP1/AJS3との連携**: これらのアクションジョブは、ジョブネット内で通常のジョブと同様に配置され、先行ジョブの終了状態に応じて実行されます。

### 6. リソース管理と並行実行

複数のジョブを同時に実行する際のシステムリソースの競合を避け、並行実行を制御します。

*   **JP1ジョブユニット**:
    *   **ジョブ実行多重度**: エージェント単位で、同時に実行できるジョブ数を制限します。
    *   **排他実行リソース**: 複数のジョブに同じリソース名を指定することで、同時実行を抑止します。
    *   **フレキシブルジョブ**: 複数のエージェントホスト間でジョブの実行を分散させます。

*   **スクリプトの概念と役割**:
    *   **目的**: システムリソースの過負荷を防ぎ、安定したジョブ運用を実現すること。
    *   **処理内容**: スクリプトは**JP1/AJS3の制御下で実行される**ことを前提とします。JP1/AJS3の排他制御とは別に、スクリプト内でファイルロックなどを実装することも可能です。
        ```bash
        #!/bin/bash
        # このスクリプトはJP1/AJS3の排他実行リソースによって同時実行が制御される
        LOCK_FILE="/shared_resource/process.lock"
        if ( set -o noclobber; echo "$$" > "$LOCK_FILE") 2> /dev/null; then
          trap 'rm -f "$LOCK_FILE"; exit $?' INT TERM EXIT
          echo "Processing shared data..."
          /opt/my_app/process_shared_data.sh
          echo "Processing complete."
          rm -f "$LOCK_FILE"
          exit 0
        else
          echo "Failed to acquire lock. Another instance is running."
          exit 1
        fi
        ```

*   **JP1/AJS3との連携**: リソースに関する設定はJP1/AJS3側で行い、スクリプトの実行をJP1/AJS3が制御します。

### 7. 実行優先順位の調整

ジョブの重要度に応じて、OS上でのプロセス優先順位を調整できます。

*   **JP1ジョブユニット**:
    *   UNIXジョブ、PCジョブなど、多くのジョブユニットで優先順位を設定できます。

*   **スクリプトの概念と役割**:
    *   **目的**: 重要なジョブが他の低優先度のジョブによってパフォーマンスが低下しないようにすること。
    *   **処理内容**: スクリプト自体が優先順位を変更するのではなく、**JP1/AJS3がジョブ定義に基づいてOSのプロセスに`nice`値（UNIXの場合）を設定して実行します**。
        ```bash
        #!/bin/bash
        # このスクリプトはJP1/AJS3によって指定されたnice値で実行される
        echo "Running high priority task..."
        # 重要な処理
        exit 0
        ```

*   **JP1/AJS3との連携**: JP1/AJS3のジョブ定義で設定された優先順位に従って、スクリプトがOSによって実行されます。

## スクリプト作成時の一般的な考慮事項（Linux環境）

JP1/AJS3で安定したジョブ運用を行うためには、実行されるスクリプトにも以下の配慮が必要です。

1.  **バックグラウンド実行を前提とする**
    *   JP1/AJS3で実行されるジョブは、**ユーザーの入力待ちや画面表示を伴う対話的なプログラムは、原則として実行できません**。必要な情報はコマンド引数やファイルから受け取るように設計します。

2.  **終了コード（リターンコード）の利用**
    *   前述の通り、スクリプトは処理の成否をJP1/AJS3に伝えるため、**適切な終了コードを返すことが最も重要です**。`exit 0`で正常、非ゼロ値で異常を示します。

3.  **標準出力と標準エラー出力の活用**
    *   `stdout`と`stderr`に出力された内容は、JP1/AJS3の実行結果ログに格納され、デバッグに非常に有用です。
    *   大量のデータを出力すると遅延の原因になる可能性があるため注意が必要です。

4.  **文字コードの一致**
    *   マネージャーホストとエージェントホスト間で**文字コードが一致している必要があります**。`ja_JP.UTF-8`または`ja_JP.utf8`が推奨されます。不一致は文字化けやデータ破損の原因となります。

5.  **ワークパスとファイルパスの指定**
    *   スクリプト内でファイルパスを指定する際は、絶対パスを使用することが推奨されます。ジョブ実行時のカレントディレクトリとなる「ワークパス」も指定可能です。

6.  **OSのリソース制限との関連**
    *   スクリプトが大量のメモリやファイルを使用する場合、JP1/AJS3起動ユーザーのリソース制限設定（カーネルパラメータなど）を確認・調整する必要があります。

7.  **環境変数の利用**
    *   JP1/AJS3は、ジョブ実行時に`JP1_USER`、`HOME`、`LANG`などの環境変数を設定します。スクリプト内でこれらの環境変数を活用できます。
