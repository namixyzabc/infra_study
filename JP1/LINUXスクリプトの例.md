

JP1/AJS3の業務自動化の基本
JP1/AJS3（Automatic Job Management System 3）は、定型的・定期的な業務を自動化するための製品です。複雑な業務フローにも対応しており、業務を自動的に実行するためには、以下の2つの要素を定義する必要があります:

業務内容と実行順序: 一つ一つの作業を「ジョブ」として定義し、それらをまとめて実行順序を関連づけたものを「ジョブネット」として定義します。ジョブの最小単位は、コマンド、アプリケーションプログラム、シェルスクリプトなどです。
業務を実行するスケジュール、または業務の契機となる事象: 毎日、毎月といった決まったスケジュールに従って実行することも、ファイルの作成やイベントの発生などを契機として実行することも可能です。

JP1/AJS3は、マネージャーホストとエージェントホストの構成で、複数のホストにまたがる業務を一元的に管理できます。マネージャーホストは業務を管理し、エージェントホストは実際に業務（ジョブ）を実行します。
ジョブの実行環境とユーザー管理
JP1/AJS3のジョブ実行において、ユーザー管理とアクセス権限の設定は非常に重要です。特に、Linux環境では、JP1ユーザーとOSユーザーのマッピングがジョブの実行権限に直結します。

ユーザーマッピングの概念: 「ユーザーマッピング」とは、処理の実行先ホスト上でJP1ユーザーとOSユーザーを対応づける操作のことです。JP1/AJS3では、ジョブを実行する際に、JP1ユーザーに対応づけられているOSユーザーの権限で実行ファイルなどのOS資源にアクセスし、処理を実行します。

マネージャーホストでの設定: マネージャーホストのJP1/Baseのセットアップでは、JP1専用のアカウントであるJP1ユーザーの登録、JP1ユーザーの操作権限の設定（JP1権限レベル）、そしてユーザーマッピングが実施されます。
エージェントホストでの設定: エージェントホストでも、マネージャーホストに登録したJP1ユーザーとエージェントホストのOSユーザーを対応づけて、JP1ユーザーがエージェントホストのOS資源にアクセスできるようにユーザーマッピングが必要です。
設定手順 (CLI/GUI): ユーザーマッピングは、Windows環境ではJP1/Baseの環境設定ダイアログボックス（GUI）を通じて行われ、JP1ユーザー名、サーバーホスト名（実行要求元ホスト）、そしてマッピングするOSユーザーを指定します。Linux環境では、jbsmkumapコマンドとユーザーマッピング定義ファイルを編集することで設定できます。
自動初期設定: JP1/Baseを新規にインストールすると、jp1adminというJP1ユーザーが自動で初期設定され、OSユーザーのrootにマッピングされます。このデフォルトユーザーを使って運用する場合は、JP1/Baseのセットアップは不要な場合があります。

ジョブ実行時の権限:

UNIX環境のジョブは、ユーザーマッピングで変換された実行OSユーザーのローカルログインスクリプトが読み込まれ、特に指定がない限り、その実行OSユーザーのログインシェルで実行されます。
PCジョブ、UNIXジョブ、HTTP接続ジョブでは、実行時に使用するOSユーザーを明示的に指定できます（「実行時のユーザー」）。このOSユーザーは、JP1ユーザー（登録ユーザーまたは所有ユーザー）にマッピングされている必要があります。
イベントジョブは、エージェントホストのJP1/AJS3を起動しているユーザー権限で実行されるため、「実行ユーザー種別」を指定しても無効です。
実務でよく使われる処理内容とJP1ユニットの連携
ここでは、Linux環境におけるJP1/AJS3での実務シナリオと、それに対応するJP1ジョブユニットの利用、およびスクリプトの概念的な役割について詳述します。
1. 定型的なバッチ処理の自動実行
多くのシステムでは、日次、月次、週次などの決まったタイミングで、データ集計、レポート作成、ファイル転送などのバッチ処理が実行されます。

JP1ジョブユニット:

UNIXジョブ: Linux環境でシェルスクリプトや実行ファイルを直接実行するジョブです。最も基本的なジョブ単位となります。
ジョブネット: 複数のUNIXジョブを実行順序に従って自動実行するために使用します。
スケジュール: ジョブネットをいつ実行するかを定義します。特定の時刻や曜日、日付などを指定できます。

スクリプトの概念と役割:

目的: データの入力、集計、帳票作成、プリンタ出力といった一連の業務処理を、定義された順序で実行すること。
処理内容:
データの取得・加工: 例えば、特定のディレクトリから最新の売上データを取得し、整形するシェルスクリプト (get_sales_data.sh)。
: #!/bin/bash SOURCE_DIR="/data/sales/raw" TARGET_DIR="/data/sales/processed" TIMESTAMP=$(date +"%Y%m%d%H%M%S") LOG_FILE="/var/log/my_batch/get_sales_${TIMESTAMP}.log" ERROR_LOG="/var/log/my_batch/get_sales_error_${TIMESTAMP}.log" mkdir -p "${TARGET_DIR}" "${LOG_FILE%/*}" if [ -f "${SOURCE_DIR}/daily_sales.csv" ]; then   cp "${SOURCE_DIR}/daily_sales.csv" "${TARGET_DIR}/daily_sales_${TIMESTAMP}.csv" >> "${LOG_FILE}" 2>> "${ERROR_LOG}"   if [ $? -eq 0 ]; then     echo "Sales data copied successfully." >> "${LOG_FILE}"     exit 0 # 正常終了   else     echo "Error copying sales data." >> "${ERROR_LOG}"     exit 1 # 異常終了   fi else   echo "Source file daily_sales.csv not found." >> "${ERROR_LOG}"   exit 2 # ファイル不在エラー fi
集計処理: 加工されたデータを基に、別のスクリプトがデータベースを更新したり、レポートを生成したりします (aggregate_data.sh)。
: #!/bin/bash PROCESSED_FILE="/data/sales/processed/daily_sales_$(date +"%Y%m%d")*.csv" if [ -f "${PROCESSED_FILE}" ]; then   /opt/my_app/bin/sales_aggregator -i "${PROCESSED_FILE}" -o "/data/sales/reports/daily_summary_$(date +"%Y%m%d").txt"   if [ $? -eq 0 ]; then     echo "Aggregation successful."     exit 0   else     echo "Aggregation failed. Check application logs."     exit 1   fi else   echo "Processed file not found for aggregation."   exit 1 fi
レポート配信: 生成されたレポートを関係者にメールで送信したり、FTPで転送したりする処理 (distribute_report.sh)。
: #!/bin/bash REPORT_FILE="/data/sales/reports/daily_summary_$(date +"%Y%m%d").txt" if [ -f "${REPORT_FILE}" ]; then   /usr/bin/mail -s "Daily Sales Summary" recipient@example.com < "${REPORT_FILE}"   if [ $? -eq 0 ]; then     echo "Report sent successfully."     exit 0   else     echo "Failed to send report."     exit 1   fi else   echo "Report file not found."   exit 1 fi
JP1/AJS3との連携: スクリプトは、JP1/AJS3がジョブの成否を判断できるように、**適切な終了コード（リターンコード）**を返す必要があります。通常、0は正常終了、0以外は異常終了を示します。JP1/AJS3は、この終了コードに基づいて次のジョブの実行を制御したり、エラー通知を発行したりします。
2. イベント駆動型処理
決まった時刻ではなく、特定の事象が発生したことを契機に業務を開始したい場合に利用されます。

JP1ジョブユニット:

イベントジョブ: 特定の事象（ファイル作成・更新・削除、JP1イベントの受信、ログファイルへのログ書き込み、Windowsイベントログへのイベント出力など）を監視し、その発生を検知するとジョブネットを開始する機能を提供します。Linux環境では、主にファイル監視ジョブ、JP1イベント受信監視ジョブ、ログファイル監視ジョブが利用されます.
ファイル監視ジョブ: 指定したファイルが存在するかどうか、または更新されたかを監視します。
JP1イベント受信監視ジョブ: JP1イベントサービスに登録されたJP1イベントを監視します。
ログファイル監視ジョブ: ログファイルに特定の文字列が出力されたことを監視します。正規表現も利用可能です。
ジョブネット: イベントジョブが検知した事象をトリガーとして、後続の業務処理を行うジョブネットが実行されます。

スクリプトの概念と役割:

目的: 外部システムやユーザー操作によって発生する非定形なイベントに対応し、自動的に業務を開始すること.
処理内容:
ファイル到着時の処理: 例えば、外部からデータファイルがFTPで転送されてきたら、そのファイルを処理するジョブネットを開始する。
（ファイル監視ジョブの設定）: 監視対象ファイル名: /incoming/data/*.csv （または特定のファイル名）, 監視条件: 「ファイルが存在すれば正常」または「ファイルのサイズ変更」。
（後続のUNIXジョブのスクリプト）: #!/bin/bash for file in /incoming/data/*.csv; do   if [ -f "$file" ]; then     /opt/data_processor/process_csv.sh "$file"     if [ $? -eq 0 ]; then       mv "$file" /incoming/data/processed/     else       mv "$file" /incoming/data/failed/       exit 1 # 処理失敗     fi   fi done exit 0
システムログからの異常検知: 例えば、/var/log/messagesに特定の致命的なエラーメッセージが出力されたら、管理者へ緊急通知するジョブネットを開始する。
（ログファイル監視ジョブの設定）: 監視対象ログファイル名: /var/log/messages, 監視文字列: CRITICAL_ERROR.*Failed (正規表現)。
（後続のアクションジョブ（メール送信ジョブ）のスクリプト）: このジョブはJP1/AJS3の組み込み機能としてメールを送信するため、ユーザーが直接スクリプトを書く必要は基本的にありません。設定ダイアログで宛先、件名、本文などを指定します。

JP1/AJS3との連携: イベントジョブは、監視条件が成立するとJP1/AJS3内部でイベントを発生させ、それがジョブネットの起動条件を満たすことで後続のジョブが実行されます。スクリプトが直接イベントを発生させる場合（例：jevsendコマンド）、JP1イベント受信監視ジョブでそのイベントを捕捉できます。
3. 条件分岐とエラーリカバリー
業務処理では、先行する処理の結果によって次の処理を変えたり、エラーが発生した場合に自動的に回復を試みたりすることが不可欠です。

JP1ジョブユニット:

判定ジョブ: 先行ジョブの終了コード（戻り値）やファイルの有無などに基づいて、後続ジョブの実行を制御します。if-then-elseのようなロジックをJP1/AJS3のレベルで実現できます。
リカバリージョブ: 特定のジョブが異常終了した場合にのみ実行されるジョブを定義できます。
リトライ設定: ジョブが起動失敗または異常検出終了した場合に、自動的に再実行を試みる設定です。リトライ回数や間隔を指定できます.

スクリプトの概念と役割:

目的: 業務フローの柔軟性を高め、障害発生時の手動介入を最小限に抑え、システムの可用性を向上させること.
処理内容:
終了コードによる条件分岐: 例えば、データ処理スクリプトが成功した場合はレポート生成に進み、失敗した場合はエラー通知とリカバリー処理に進む。
（データ処理UNIXジョブのスクリプト）: #!/bin/bash /opt/my_app/process_data.sh exit $? # 実行結果をそのままJP1に返す
（JP1/AJS3の設定）: このUNIXジョブの後続に判定ジョブを配置し、終了コードが0の場合は正常パス、0以外の場合は異常パスに進むように設定します。
リカバリー処理: 例えば、集計処理が失敗した場合、ログを収集して管理者にメール通知し、その後、必要に応じて失敗した集計処理を再試行する。
（集計処理UNIXジョブのリカバリージョブとして設定するスクリプト）: #!/bin/bash LOG_PATH="/var/log/my_batch/aggregation_error.log" cp /tmp/current_aggregation.log "${LOG_PATH}" echo "Aggregation failed. Log collected at ${LOG_PATH}. Sending notification..." /usr/bin/mail -s "CRITICAL: Aggregation Failed" admin@example.com < "${LOG_PATH}" # 必要に応じて、ここで簡易的なリカバリーコマンドを実行する # /opt/my_app/bin/cleanup_failed_aggregation.sh exit 0 # リカバリー処理自体は正常終了としてJP1に報告
JP1/AJS3との連携: スクリプトは常に正確な終了コードを返すことが重要です。JP1/AJS3は、この終了コードを基に判定ジョブやリカバリージョブの実行を決定します。リトライ設定を利用する場合、スクリプトは一時的なエラーであれば再度実行されても問題ない冪等性（べきとうせい）を持つことが望ましいです。
4. ジョブ間のデータ連携
先行ジョブの出力情報を後続ジョブで利用したい場合に、動的に変化する情報を引き継ぐことができます。

JP1ジョブユニット:

引き継ぎ情報設定ジョブ: 先行ジョブが出力した標準出力ファイルから必要な情報を切り出して、後続ジョブに引き継ぐためのジョブです。
マクロ変数: 引き継ぎ情報設定ジョブで切り出された情報は、マクロ変数として後続ジョブで使用されます。

スクリプトの概念と役割:

目的: ジョブネット内の各ジョブが連携して動作するために、実行時に動的に生成されるデータを共有すること.
処理内容:
先行ジョブの標準出力: 例えば、ファイルパスを生成するスクリプトが、そのパスを標準出力に出力する。
（ファイルパス生成UNIXジョブのスクリプト）: #!/bin/bash GENERATED_FILE_NAME="report_$(date +"%Y%m%d%H%M%S").txt" echo "/data/reports/${GENERATED_FILE_NAME}" exit 0
引き継ぎ情報設定ジョブでの情報切り出し: JP1/AJS3の引き継ぎ情報設定ジョブの定義で、先行ジョブの標準出力から特定のパターン（正規表現など）で文字列を抽出し、それをマクロ変数に設定します。
(概念的な設定): 先行ジョブの標準出力から /data/reports/ で始まる行を抽出し、その全体を$$FILE_PATH$$というマクロ変数に設定する。
後続ジョブでのマクロ変数利用: 後続のジョブ（UNIXジョブなど）が、このマクロ変数を自身のスクリプトの引数や環境変数として利用する。
（後続のレポート処理UNIXジョブのスクリプト）: #!/bin/bash REPORT_FILE="$$FILE_PATH$$" if [ -f "${REPORT_FILE}" ]; then   /opt/my_app/generate_pdf_from_report.sh "${REPORT_FILE}"   exit $? else   echo "Report file ${REPORT_FILE} not found."   exit 1 fi
JP1/AJS3との連携: 先行ジョブは結果を標準出力に出力し、引き継ぎ情報設定ジョブがそれを解析し、マクロ変数として登録します。後続ジョブの実行環境には、JP1/AJS3によってこれらのマクロ変数が展開された状態でスクリプトに渡されます。標準出力ファイルサイズには制限（4,096バイト）がある点に注意が必要です。
5. 通知とレポート
ジョブの実行結果やシステムの状態を、関係者に自動的に通知する機能です。

JP1ジョブユニット:

メール送信ジョブ: ジョブが異常終了した場合や、重要な処理が完了したときなどに、メールで関係者に通知を送ります。リカバリージョブとして定義することも多いです。
JP1イベント送信ジョブ: JP1イベントをJP1/Baseのイベントサービスに登録します。このイベントはJP1/IM（Integrated Manager）などで監視され、集中監視や自動アクションのトリガーとなります。
JP1/Cm2状態通知ジョブ: JP1/Cm2/NNMなどのネットワーク管理システムに状態を通知します.

スクリプトの概念と役割:

目的: システムの状況変化をタイムリーに伝達し、問題の早期発見と対応を促すこと.
処理内容: これらのジョブは、JP1/AJS3の機能として提供されるため、通常、ユーザーが直接スクリプトを記述することはありません。JP1/AJS3 - Viewのダイアログボックスやコマンドで、宛先、件名、本文、メッセージID、拡張属性などを設定します。
（メール送信ジョブの例）: ジョブネット中のUNIXジョブが異常終了した場合、そのリカバリージョブとしてメール送信ジョブを設定し、異常終了したジョブのログ情報などを本文に含めて送信する。
（JP1イベント送信ジョブの例）: 重要なバッチ処理が正常終了した際に、JP1イベントを送信し、JP1/IMでそのイベントを検知して、システム全体のダッシュボードを更新したり、次のシステム連携処理を開始したりする。

JP1/AJS3との連携: これらのアクションジョブは、ジョブネット内で通常のジョブと同様に配置され、先行ジョブの終了状態（正常/異常）に応じて実行されます。
6. リソース管理と並行実行
複数のジョブを同時に実行する際のシステムリソースの競合を避けたり、特定の処理の並行実行を制御したりします。

JP1ジョブユニット:

ジョブ実行多重度: 同時に実行できるジョブの数を制限する設定です。エージェント単位で設定できます。
排他実行リソース: 複数のジョブの同時実行を抑止したい場合に、それぞれのジョブで同じリソース名を指定することで、同時実行を制御します。
フレキシブルジョブ: 複数のエージェントホスト間でジョブの実行を分散させたり、特定の条件下で実行先を動的に変更したりする場合に使用されます。特に、実行エージェントグループを指定することで、ジョブの負荷分散が可能です。

スクリプトの概念と役割:

目的: システムリソースの過負荷を防ぎ、安定したジョブ運用を実現すること.
処理内容: スクリプト自体は、リソースの競合を直接制御するものではなく、JP1/AJS3の制御下で実行されることを前提とします。スクリプトがファイルやデータベースなどの共有リソースにアクセスする場合、スクリプト内でロック機構や排他制御を実装する必要があるかもしれません（これはJP1/AJS3の機能とは独立した、アプリケーション側の配慮です）。
: #!/bin/bash # JP1/AJS3の排他実行リソースによって、このスクリプトは他の同名リソースを持つジョブと並行して実行されない # スクリプト内で共有ファイルへの書き込みなどを行う場合、別途ファイルロックなどを考慮することもできる LOCK_FILE="/shared_resource/process.lock" if ( set -o noclobber; echo "$$" > "$LOCK_FILE") 2> /dev/null; then   trap 'rm -f "$LOCK_FILE"; exit $?' INT TERM EXIT   echo "Processing shared data..."   # 共有リソースへのアクセス処理   /opt/my_app/process_shared_data.sh   echo "Processing complete."   rm -f "$LOCK_FILE"   exit 0 else   echo "Failed to acquire lock. Another instance is running."   exit 1 fi
JP1/AJS3との連携: ジョブ実行多重度や排他実行リソースの設定はJP1/AJS3側で行い、スクリプトの実行をJP1/AJS3が制御します。フレキシブルジョブの場合、JP1/AJS3はジョブを中継エージェントに転送し、そこから宛先エージェントに実行要求が行われます。
7. 実行優先順位の調整
システム内で実行されるジョブの重要度に応じて、OS上でのプロセス優先順位を調整できます。

JP1ジョブユニット:

UNIXジョブ、PCジョブ、HTTP接続ジョブ、フレキシブルジョブ、引き継ぎ情報設定ジョブ、アクションジョブ、カスタムジョブなどのジョブユニットは、それぞれに優先順位を設定できます。

スクリプトの概念と役割:

目的: 重要なジョブが他の低優先度のジョブによってパフォーマンスが低下しないようにすること。
処理内容: スクリプト自体が直接OSのプロセス優先順位を設定するのではなく、JP1/AJS3がジョブの定義で設定された優先順位に基づいて、OSのプロセスにnice値（UNIXの場合）や基本優先度（Windowsの場合）を設定して実行します。
UNIXの場合: JP1/AJS3は、ジョブに設定された優先順位（1〜5）に応じて、OSのnice値を調整します。nice値が小さいほど高優先度です。
: JP1/AJS3のジョブ定義で優先順位「1」（最も高い）を設定すると、JP1/AJS3サービスのnice値から20を加算（nice値は増加するほど優先度が低くなるため、実際にはJP1/AJS3が内部で調整）された、実質的な高優先度で実行されます。キューレスジョブの場合、JP1/AJS3サービスのnice値は基準にならず、直接nice値が設定されます。
(スクリプトからの直接的な設定は非推奨、JP1経由で設定される): #!/bin/bash # このスクリプトはJP1/AJS3によって指定されたnice値で実行される # (スクリプト内で直接niceコマンドを使用することも可能だが、JP1の管理を推奨) echo "Running high priority task..." # 重要な処理 exit 0
JP1/AJS3との連携: スクリプトの実行ファイルやコマンド自体は、優先順位を直接変更するコードを含まなくても、JP1/AJS3のジョブ定義で設定された優先順位に従ってOSによって実行されます。
スクリプト作成時の一般的な考慮事項（Linux環境）
JP1/AJS3で安定したジョブ運用を行うためには、実行されるスクリプトにもいくつかの配慮が必要です。

バックグラウンド実行を前提とする:

JP1/AJS3で実行されるジョブは、通常、OSのサービス空間でバックグラウンド実行されます。そのため、ユーザーの入力待ちや画面表示を伴う対話的なプログラムは、原則として実行できません。スクリプトは、必要な情報をコマンド引数やファイルから受け取り、結果を標準出力やファイルに出力するように設計する必要があります。
どうしても対話型のプログラムを実行したい場合は、jp1scriptのようなログオン空間での実行をサポートするJP1/Script連携を検討する必要があります（ただし、Linux環境ではJP1/ScriptはWindows用です）。

終了コード（リターンコード）の利用:

前述の通り、スクリプトは処理の成否をJP1/AJS3に伝えるために、適切な終了コードを返すことが最も重要です。exit 0で正常終了、exit 1（またはその他の非ゼロ値）で異常終了を示すのが一般的です。
JP1/AJS3は、この終了コードに基づいて、後続ジョブの実行、リカバリー処理、通知などを制御します。

標準出力と標準エラー出力の活用:

スクリプトが標準出力（stdout）に出力した内容は、JP1/AJS3の実行結果ログに格納され、JP1/AJS3 - Viewで確認できます。これはジョブの実行状況やデバッグ情報として非常に有用です。
標準エラー出力（stderr）も同様に記録され、異常発生時の詳細な原因調査に役立ちます。
大量のデータ（数MBを超える）を標準出力/エラー出力に転送すると、システムに負荷がかかり、ジョブの実行が遅延する可能性があります。この場合、ファイル送信制限の設定を調整することを検討してください。また、引き継ぎ情報設定ジョブで利用できる標準出力のサイズは4,096バイトまでです。

文字コードの一致:

マネージャーホストとエージェントホスト間でジョブやファイルのやり取りをする際、文字コードが一致している必要があります. 特にUNIX環境では、OSの環境変数LANGの値がJP1/AJS3で使用する言語と同じである必要があります. ja_JP.UTF-8またはja_JP.utf8が推奨されています.
文字コードが一致していない場合、文字化けや定義データの破損、エラーメッセージの出力などの問題が発生する可能性があります.
ファイル転送を行う場合、転送元ファイルの文字コードと、転送先（受信側）のJP1/AJS3サービスの文字コードを一致させる必要があります。

ワークパスとファイルパスの指定:

ジョブの実行時にカレントディレクトリとなる「ワークパス」を指定できます。省略した場合、実行OSユーザーのホームディレクトリが仮定され、ホームディレクトリが未定義の場合はルートディレクトリ (/) が仮定されます.
スクリプト内でファイルパスを指定する際は、絶対パスを使用するか、JP1/AJS3が提供するワークパスの機能（環境変数としてワークパスを設定する機能など）を考慮に入れると良いでしょう.
ネットワークドライブ名を直接使用するのではなく、「//コンピュータ名/共有フォルダ/ファイル名」のようにコンピュータ名から始まるパスを指定することが推奨されています。

OSのリソース制限との関連:

UNIX版JP1/AJS3では、JP1/AJS3起動時のリソース制限値がジョブ実行時にも有効になります. スクリプトが大量のファイルを開いたり、多くのメモリを消費したりする可能性がある場合、JP1/AJS3の起動ユーザー（rootユーザー）のリソース制限設定を確認・調整する必要があります。
具体的には、カーネルパラメーターのファイルサイズ、共有メモリ、プロセス数などの設定値が適切に見積もられているか確認することが重要です。

環境変数の利用:

JP1/AJS3は、ジョブ実行時に特定の環境変数を設定します（例: JP1_USER、JP1Priority、HOME、SHELL、LANG、LOGNAMEなど）。スクリプト内でこれらの環境変数を参照することで、JP1/AJS3からの情報を活用できます。
ジョブ定義時に、スクリプトに渡すカスタムの環境変数を追加で設定することも可能です（ただし、ソース資料の表によると環境変数は「×」と記載されている箇所もあるため、使用できる環境変数とできない環境変数を区別して理解する必要があります）。

