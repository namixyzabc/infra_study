

# AWSアンチパターンとベストプラクティス

## 1\. アカウント管理と認証・権限（Account & IAM）

最初の設計で最も重要なのがアカウント構造と権限管理です。ここを誤ると、セキュリティと運用効率の両面で長期的な負債となります。

### アンチパターン：全環境を単一アカウントで運用する

本番（Production）、ステージング（Staging）、開発（Development）のすべての環境を1つのAWSアカウント内に構築する構成です。

> **❌ 具体例：**
> *   EC2インスタンス一覧画面に、`prod-web-server` と `dev-test-server` が混在して並んでいる。
> *   開発者がテストサーバーを再起動しようとして、誤って **本番サーバーを「終了（削除）」** してしまった。

* **問題点**  
  * **誤操作のリスク：** 開発作業中に誤って本番リソースを操作・削除してしまう危険性が常にあります。  
  * **権限管理の複雑化：** 開発メンバーへの権限付与が複雑になり、安全なアクセス制御が困難になります。  
  * **サービス上限（Quota）の競合：** 検証環境での負荷テストが本番環境のAPI制限などに影響を与える可能性があります。  

* **推奨される構成：AWS Organizationsによるアカウント分離**  
  * 最初から環境ごとにAWSアカウントを分離し、AWS Organizationsで統合管理します。  
  * **SCP（Service Control Policy）の活用：** 組織全体で「特定リージョンの使用禁止」や「リソースの削除禁止」などのガードレールを設定します。

> **✅ 具体例：**
> *   **アカウント構成：**
>     *   管理用アカウント（請求・監査用）
>     *   本番環境アカウント（Production）
>     *   開発環境アカウント（Development）
> *   **SCP設定：** 開発アカウントに対して「`us-east-1`（バージニア）以外のリージョンでのリソース作成を禁止」するポリシーを適用し、予期せぬ海外リージョンでの課金を防ぐ。

### アンチパターン：ルートユーザー（Root User）の日常利用

全権限を持つルートユーザーのアカウントを日常的な構築や運用に使用する行為です。

> **❌ 具体例：**
> *   社内Wikiに「AWSログイン情報」として、ルートユーザーのメールアドレスとパスワードが共有されている。
> *   「MFAデバイス（認証アプリ）が入ったスマホを持つ担当者」が休むと、誰も管理画面に入れない。

* **問題点**  
  * ルートユーザーが乗っ取られた場合、アカウントの制御を完全に失い、取り返しがつかない被害（全リソース削除、高額請求など）を受けます。  

* **推奨される構成：ルートユーザーの封印とIAMの利用**  
  * ルートユーザーはアカウント作成時や請求設定の変更など、緊急時のみ使用します。  
  * 必ず強固なパスワードとMFA（多要素認証）を設定し、アクセスキーは作成しません（存在する場合は削除します）。

> **✅ 具体例：**
> *   ルートユーザーのパスワードは金庫や厳重なパスワード管理ツールに保管する。
> *   MFAには個人のスマホではなく、物理的なセキュリティキー（YubiKeyなど）を使用し、物理的に施錠保管する。

### アンチパターン：IAMユーザーをアカウントごとに個別に発行する

各AWSアカウントで個別にIAMユーザーを作成・配布し、アクセスキーを永続的に利用させる運用です。

> **❌ 具体例：**
> *   社員Aさんが入社したため、本番・検証・開発の3つのアカウントそれぞれでIAMユーザー作成作業を行う。
> *   Aさんが退職した際、検証環境のアカウントだけ **ユーザー削除を忘れてしまい**、退職後もアクセス可能な状態が続いていた。

* **問題点**  
  * アカウント数に比例して管理すべき認証情報が増加します。  
  * 退職や異動時の削除漏れが発生しやすく、セキュリティホールになります。  
  * MFA未設定のまま運用されるケースが多く、アカウント侵害のリスクが高まります。  

* **推奨される構成：IAM Identity Centerによる認証の一元化**  
  * IAMユーザーの個別発行をやめ、IAM Identity Center（旧AWS SSO）で認証を一元化します。  
  * 一度のログインで複数のアカウントへ、適切な権限（スイッチロール）でアクセスできるようにします。

> **✅ 具体例：**
> *   社員は1つのポータル画面（SSO）にログインするだけ。
> *   画面上に「本番環境（閲覧のみ）」「開発環境（管理者）」といった許可された役割だけが表示され、クリック一つでアクセスできる。
> *   退職時はSSOの大元（Google WorkspaceやActive Directory等）を停止すれば、全AWSアカウントへ入れなくなる。

### アンチパターン：CI/CDやSDKにIAMユーザーのアクセスキーを埋め込む

GitHub ActionsやCircleCI、アプリケーションのソースコードに、IAMユーザーのアクセスキー（AK/SK）を直接設定する手法です。

> **❌ 具体例：**
> *   ソースコード内の `.env` ファイルに `AWS_ACCESS_KEY_ID=AKIA...` と書いてあり、それを誤ってGitHubの公開リポジトリにPushしてしまった。
> *   **結果：** 数分以内に不正利用ボットに見つかり、世界中で高額なインスタンスを大量起動されてしまう。

* **問題点**  
  * キーが流出した場合、即座に不正利用されるリスクがあります（GitHubへの誤コミットによる流出事故は頻発しています）。  
  * キーのローテーション管理が必要となり、運用負荷が高まります。  

* **推奨される構成：OIDCプロバイダーとIAMロールを利用する**  
  * GitHub ActionsなどのCIツールからは、OIDC（OpenID Connect）を利用し、一時的な認証情報でアクセスします。  
  * EC2やLambdaなどのAWSリソース内では、IAMロールを割り当ててアクセス権限を付与します。

> **✅ 具体例：**
> *   GitHub ActionsのYAMLファイル：
>   ```yaml
>   - name: Configure AWS Credentials
>     uses: aws-actions/configure-aws-credentials@v2
>     with:
>       role-to-assume: arn:aws:iam::123456789012:role/GitHubActionRole
>       aws-region: ap-northeast-1
>   ```
>   ※ アクセスキー（AKIA...）を一切記述せず、AWS側で発行した一時的な権限のみを使用する。

### アンチパターン：過度な権限付与（AdministratorAccessの常用）

「とりあえず動かないと困るから」といって、開発者やアプリケーション用ロールに`AdministratorAccess`や`Action: "*"`を付与するケースです。

> **❌ 具体例：**
> *   Webサーバー用のIAMロールに `AdministratorAccess` が付いている。
> *   Webアプリに脆弱性がありハッキングされた結果、そのサーバー経由でIAMユーザーを作成され、アカウント全体が乗っ取られる。

* **問題点**  
  * 最小権限の原則（Least Privilege）に違反し、誤操作や侵害時の被害範囲が最大化します。  

* **推奨される構成：最小権限の原則とIAM Access Analyzerの活用**  
  * 職務や役割に必要な権限のみを付与したポリシーを作成します。  
  * IAM Access Analyzerを使用して、実際に使用されたアクションに基づいたポリシーを生成・修正します。

> **✅ 具体例：**
> *   S3から画像を読み込むだけのアプリなら、以下のようなポリシーのみを許可する。
>   ```json
>   {
>     "Effect": "Allow",
>     "Action": ["s3:GetObject", "s3:ListBucket"],
>     "Resource": ["arn:aws:s3:::my-app-images/*"]
>   }
>   ```

---

## 2\. ネットワークと基本設計（Network & Basic Design）

ネットワーク設計のミスは、サービス停止や作り直しに直結する深刻な領域です。

### アンチパターン：VPCサブネット設計の考慮不足（単一AZ、IP枯渇）

役割や可用性ゾーン（AZ）を考慮せず、適当なCIDRブロックでサブネットを作成したり、単一のAZのみにリソースを配置したりするケースです。

> **❌ 具体例：**
> *   VPCを `10.0.0.0/16` で作成したが、サブネットも `10.0.0.0/16` で一つだけ作成してしまった（これ以上サブネットを切れない）。
> *   すべてのサーバーを `ap-northeast-1a` だけに置いているため、データセンター障害時に全サービスが停止する。

* **問題点**  
  * **IPアドレスの枯渇：** コンテナやLambda（VPC内）の利用拡大時にIPが不足し、リソースを追加できなくなります。  
  * **可用性の欠如：** 単一AZ構成の場合、そのAZでの障害発生時にサービス全体が停止します。  

* **推奨される構成：役割とAZを考慮した余裕のある設計**  
  * **マルチAZ構成：** 必ず2つ以上のAZを使用し、冗長化します。  
  * **CIDR設計：** VPCには`/16`、サブネットには`/20`〜`/24`など、将来の拡張を見越したサイズを割り当てます。  
  * **重複の回避：** 将来的なVPCピアリングやTransit Gateway接続を見越し、オンプレミスや他VPCと重複しないプライベートIP帯域を選定します。

> **✅ 具体例：**
> *   **AZ構成：** `ap-northeast-1a` と `1c` の2つを利用。
> *   **サブネット：**
>     *   Public-1a (`10.0.1.0/24`) / Public-1c (`10.0.2.0/24`)
>     *   Private-1a (`10.0.10.0/24`) / Private-1c (`10.0.11.0/24`)
>     *   DB-1a (`10.0.20.0/24`) / DB-1c (`10.0.21.0/24`)

### アンチパターン：バックエンドリソース（RDS/ECS等）をパブリックサブネットに配置する

「インターネットからアクセスしたい」という理由で、データベースやアプリケーションサーバーをパブリックサブネットに配置する構成です。

> **❌ 具体例：**
> *   RDSの設定で「パブリックアクセス：有効」にし、開発者のPCから直接DBツールで接続している。
> *   世界中のハッカーからポート3306（MySQL）に対してパスワード総当たり攻撃を受け続ける。

* **問題点**  
  * インターネットからの直接攻撃（ポートスキャン、ブルートフォース攻撃）の対象となります。  

* **推奨される構成：プライベートサブネットへの配置と踏み台の排除**  
  * RDS、ECS、ElastiCacheなどのバックエンドリソースは必ずプライベートサブネットに配置します。  
  * 外部からのアクセスが必要な場合はALB（ロードバランサー）を経由させます。  
  * 管理目的のSSH/RDP接続には、パブリックな踏み台サーバー（Bastion）ではなく、**AWS Systems Manager Session Manager**を利用し、ポート開放なしで安全に接続します。

> **✅ 具体例：**
> *   RDSはプライベートサブネットに配置（外部からIP到達不可）。
> *   接続する際は、同じVPC内のEC2を経由するか、VPNまたはClient VPNを使用する。
> *   管理者はAWSコンソールから「セッションマネージャー」をクリックするだけで、SSH鍵なしで安全にサーバー操作を行う。

### アンチパターン：全トラフィック許可（Any）のセキュリティグループ

インバウンド・アウトバウンド共に「すべてのトラフィックを許可（`0.0.0.0/0`）」する設定です。

> **❌ 具体例：**
> *   接続できないトラブルを避けるため、とりあえずインバウンドルールに「Type: All Traffic, Source: 0.0.0.0/0」を設定して放置。
> *   Webサーバーだけでなく、管理用SSHポートやDBポートまで世界中に公開されてしまう。

* **問題点**  
  * 意図しない経路からのアクセスを許し、攻撃に対し無防備になります。  
  * どのリソースがどこへ通信しているのか依存関係が不明瞭になります。  

* **推奨される構成：セキュリティグループの参照（Chaining）**  
  * IPアドレスでの許可ではなく、接続元のセキュリティグループIDを指定して許可します（例：RDSのSGは、WebサーバーのSGからの通信のみ許可する）。

> **✅ 具体例：**
> *   **Webサーバー用SG (`sg-web`)**: 0.0.0.0/0 からの HTTPS(443) を許可。
> *   **DBサーバー用SG (`sg-db`)**: `sg-web` からの MySQL(3306) のみ許可。
>   ※ これにより、Webサーバー以外からのDB接続は一切拒否される。

### アンチパターン：すべての通信をNAT Gateway経由にする

プライベートサブネットからの通信をすべてNAT Gatewayに集約する構成です。

> **❌ 具体例：**
> *   プライベートサブネットにあるサーバーからS3へ毎日1TBのデータをバックアップしている。
> *   その通信がすべてNAT Gatewayを経由しているため、**「NAT Gateway処理料金」だけで月に数万円〜数十万円** かかってしまった。

* **問題点**  
  * S3やDynamoDBへの大量のトラフィックがNAT Gatewayを経由すると、データ処理料金が高額になります。  
  * サブネットごとにNAT Gatewayを乱立させると、固定費（時間課金）が増大します。  

* **推奨される構成：VPC Endpointの活用と集約**  
  * **Gateway型エンドポイント：** S3とDynamoDBへの通信には、無料のGateway型VPC Endpointを使用します。  
  * **NAT Gatewayの配置：** AZごとに1つ配置し、各サブネットで共有することでコストと可用性のバランスを取ります。

> **✅ 具体例：**
> *   VPCルートテーブルの設定：
>     *   `0.0.0.0/0` → `nat-12345` (インターネット行き)
>     *   `pl-xxxx (S3)` → `vpce-12345` (S3行き。**無料**)

---

## 3\. コンテナとアプリケーション（Compute & Application）

モダンなアプリケーション基盤においても、運用を阻害する設定ミスが散見されます。

### アンチパターン：ECRのlatestタグでの本番デプロイ

Dockerイメージのタグに`latest`を指定して本番環境にデプロイする運用です。

> **❌ 具体例：**
> *   ECSタスク定義でイメージ指定を `my-app:latest` にしている。
> *   デプロイ後にバグが見つかったが、前回正常に動いていた `latest` がどの時点のイメージかわからず、**ロールバック（切り戻し）ができない**。

* **問題点**  
  * 現在どのバージョンのコードが稼働しているか特定できません。  
  * 障害発生時に過去のバージョンへ即座に切り戻す（ロールバック）ことができません。  

* **推奨される構成：イミュータブルなタグ（コミットハッシュ等）を使用する**  
  * Gitのコミットハッシュやビルド番号をタグに使用し、コードとイメージを一対一に対応させます。

> **✅ 具体例：**
> *   `my-app:v1.0.2` や `my-app:git-a1b2c3d` のように特定可能なタグを使用する。
> *   障害時はタスク定義のタグを一つ前の番号に戻すだけで確実に復旧できる。

### アンチパターン：タスク定義やコードへの機密情報（Secrets）ベタ書き

DBのパスワードやAPIキーを、ECSタスク定義の環境変数やソースコードに直接記述する構成です。

> **❌ 具体例：**
> *   ソースコード内に `const DB_PASSWORD = "Password123!";` と書かれている。
> *   ECSタスク定義の環境変数設定画面で、平文でパスワードを入力している（AWSコンソールを見れる人なら誰でもパスワードを知れてしまう）。

* **問題点**  
  * 権限を持つユーザー全員に機密情報が見えてしまいます。  
  * ローテーション時にコード修正や再デプロイが必要になります。  

* **推奨される構成：Secrets ManagerまたはSSM Parameter Storeの利用**  
  * 機密情報は専用の管理サービスに保存し、アプリケーション起動時に参照させます。

> **✅ 具体例：**
> *   ECSタスク定義のSecrets設定で `arn:aws:ssm:...:parameter/db_password` を指定。
> *   アプリ起動時にAWSが自動的に値を取得し、環境変数として注入する（コードにはキー名しか残らない）。

### アンチパターン：モノリシックなLambda関数

単一のLambda関数にすべてのロジックを詰め込み、巨大化させる構成です。

> **❌ 具体例：**
> *   `index.js` が10MBあり、中で `if (event.path === '/login') ... else if (event.path === '/billing') ...` と全機能分岐している。
> *   「請求機能」だけ直したいのに、関係ない「ログイン機能」まで再デプロイされ、バグ混入のリスクがある。

* **問題点**  
  * コードの可読性が低下し、デバッグが困難になります。  
  * デプロイパッケージのサイズが大きくなり、コールドスタートの時間が増加します。  
  * 一部の機能変更のために全体を再デプロイする必要があります。  

* **推奨される構成：機能分割とStep Functionsの活用**  
  * 単一責任の原則に基づき関数を分割します。  
  * 複雑なワークフローはAWS Step Functionsでオーケストレーションします。

> **✅ 具体例：**
> *   `AuthFunction`、`BillingFunction`、`ImageResizeFunction` のように分割。
> *   「画像アップロード→リサイズ→DB保存」といった流れは、Lambda内で他のLambdaを呼ぶのではなく、**Step Functions** で順序を定義する。

### アンチパターン：Lambdaのコンソールでのコード編集

AWSコンソール上のエディタでLambdaのコードを直接書き換えて運用する方法です。

> **❌ 具体例：**
> *   「ちょっとした修正だから」とコンソールで直接コードを書き換え、「Deploy」ボタンを押す。
> *   別のメンバーが手元の古いコードをデプロイし、**先ほどの修正が知らぬ間に上書きされて消える**。

* **問題点**  
  * バージョン管理ができず、変更履歴が残りません。  
  * リポジトリ上のコードと実環境のコードが乖離（Config Drift）します。  

* **推奨される構成：Git管理とCI/CDによるデプロイ**  
  * Lambdaのコードも必ずGitリポジトリで管理し、CI/CDパイプラインを通じてデプロイします。

> **✅ 具体例：**
> *   ローカルでコード修正 → Git Push → GitHub ActionsやCodePipelineが自動でLambdaを更新。
> *   コンソール上の編集ボタンは使用しない（触れないように権限を絞ることも可能）。

---

## 4\. データベースとストレージ（Database & Storage）

データの損失はビジネスにとって致命的です。デフォルト設定のまま利用することにはリスクがあります。

### アンチパターン：RDS/S3のバックアップ・バージョニング無効

コスト削減や設定漏れにより、バックアップ機能を使用しないケースです。

> **❌ 具体例：**
> *   RDS作成時、「自動バックアップを有効にする」のチェックを外してしまった。
> *   S3バケット内の重要ファイルを、事務スタッフが誤って上書き保存してしまい、元のデータが消失した。

* **問題点**  
  * **RDS：** デフォルトの保持期間（7日）のまま、あるいは自動バックアップ無効化により、データ破損や論理削除時の復旧が不可能になります。  
  * **S3：** バージョニングが無効だと、誤ってファイルを上書き・削除した場合に復元できません。  

* **推奨される構成：要件に合わせた保護設定**  
  * **RDS：** サービス要件に応じた保持期間を設定し、削除保護（Deletion Protection）を有効化します。本番環境では自動マイナーバージョンアップを手動管理（無効化してメンテナンス枠で実施）とします。  
  * **S3：** 原則としてバージョニングを有効化します。古いバージョンはライフサイクルポリシーで自動削除またはGlacierへ移行し、コスト増加を防ぎます。

> **✅ 具体例：**
> *   **RDS:** バックアップ保持期間＝30日、削除保護＝有効。
> *   **S3:** バージョニング＝有効。ライフサイクル＝「最新以外のバージョンは30日後に削除」を設定し、無限に容量が増えるのを防ぐ。

### アンチパターン：S3のパブリックアクセス許可

「アクセスできないから」という理由で、安易にパブリックアクセスを許可してしまう設定です。

> **❌ 具体例：**
> *   「パブリックアクセスをすべてブロック」のチェックを外し、バケットポリシーで `Principal: "*"` （誰でも）を許可。
> *   社外秘の契約書PDFが、URLを知っている人なら誰でもダウンロードできる状態になっていた。

* **問題点**  
  * 機密データを含む全てのファイルが世界中に公開されるリスクがあります。  

* **推奨される構成：CloudFront + OAC によるセキュアな配信**  
  * S3バケットは「パブリックアクセスをすべてブロック」を有効にします。  
  * 外部公開が必要な場合は、CloudFrontとOAC（Origin Access Control）を組み合わせ、S3を直接公開せずに配信します。

> **✅ 具体例：**
> *   ユーザーは `https://cdn.mysite.com/image.jpg` (CloudFront) にアクセス。
> *   S3バケットは、CloudFrontからのアクセスのみを許可するポリシーを設定し、直接のURLアクセスは拒否する。

### アンチパターン：DBエンジンの不適切な選択

すべてのデータをRDS（リレーショナルデータベース）で処理しようとするケースです。

> **❌ 具体例：**
> *   ユーザーのセッション情報（一時的なデータ）や、商品カタログのキャッシュをすべてMySQLに保存。
> *   アクセス増大時にDBのCPUが100%になり、サイト全体が重くなる。

* **問題点**  
  * セッション管理や一時的なデータの読み書きにおいて、RDSの負荷が高まり、スケーリングのボトルネックになります。  

* **推奨される構成：適材適所のDB選択**  
  * セッション管理やキャッシュには**ElastiCache**や**MemoryDB**を利用します。  
  * スキーマレスで高スループットが必要なデータには**DynamoDB**を検討します。

> **✅ 具体例：**
> *   **会員登録データ:** RDS (整合性が重要)
> *   **ログインセッション:** ElastiCache (Redis) (高速、揮発しても再ログインさせればOK)
> *   **ゲームのハイスコア:** DynamoDB (大量の書き込みが発生)

### アンチパターン：EBSをファイルサーバーのように共有しようとする

一つのEBSボリュームを複数のEC2インスタンスから無理やりマウントしようとする構成です。

> **❌ 具体例：**
> *   WebサーバーAとBで画像を共有したいので、1つのEBSボリュームを両方にアタッチしようとしたがエラーになる（またはデータが壊れる）。

* **問題点**  
  * EBS（Multi-Attach対応の一部を除く）は基本的に単一インスタンス用であり、データ破損のリスクがあります。  

* **推奨される構成：EFSまたはS3の利用**  
  * 複数インスタンスでのファイル共有が必要な場合は、**Amazon EFS**を利用します。  
  * 静的コンテンツの共有であればS3を利用します。

> **✅ 具体例：**
> *   Webサーバー群の `/var/www/html/shared` ディレクトリに、EFSファイルシステムをマウントする。これでどのサーバーから書き込んでも即座に共有される。

---

## 5\. 運用・監視・コスト（Ops, Monitoring & Cost）

### アンチパターン：手動操作によるインフラ変更（ClickOps）

AWSマネジメントコンソールで「ポチポチ」とリソースを作成・変更する運用です。

> **❌ 具体例：**
> *   担当者が手動でサーバー設定を変更したが、どこをどう変えたか記録がない。
> *   同じ環境をもう一つ作ろうとしたとき、手順書が古くて再現できない。

* **問題点**  
  * **再現性の欠如：** 同じ環境をもう一度作ることが困難です。  
  * **ドキュメントとの乖離：** 設計書と実環境の状態がすぐに一致しなくなります。  

* **推奨される構成：Infrastructure as Code (IaC) の導入**  
  * CloudFormation、Terraform、AWS CDKなどを利用し、インフラをコードで管理します。  
  * 変更はコードレビューを経て適用し、履歴を残します。

> **✅ 具体例：**
> *   Terraformで `resource "aws_instance" "web" {...}` と記述。
> *   変更時はコードを修正して `terraform apply`。Gitに「誰が・いつ・何を変更したか」が完全に残る。

### アンチパターン：監視と通知の未設定

「動いているから大丈夫」と、CloudWatchのアラームを設定しない状態です。

> **❌ 具体例：**
> *   ディスク容量がいっぱいになりデータベースが停止。
> *   **ユーザーからの「サイトが見れません」という問い合わせ** で初めて障害に気づく。

* **問題点**  
  * ディスク容量不足やCPU高負荷によるダウンタイムが発生しても、ユーザーからのクレームまで気づけません。  

* **推奨される構成：主要メトリクスの監視**  
  * CPU、メモリ、ディスク使用率、エラートラフィックなどの主要メトリクスにアラームを設定します。  
  * AWS Budgetsを設定し、予期せぬコスト超過を早期に検知します。

> **✅ 具体例：**
> *   **アラーム:** 「CPU使用率が80%を5分間超えたら、Slackの `#alert` チャンネルに通知する」。
> *   **Budget:** 「月の利用料予測が $1,000 を超えたらメールで通知する」。

### アンチパターン：不要リソースの放置（コストの無駄）

削除忘れによる「ゾンビリソース」が課金され続ける状態です。

> **❌ 具体例：**
> *   検証用EC2インスタンスを削除したが、「Elastic IP」を解放し忘れていた。
> *   サーバーに紐付いていないIPアドレス代として、**毎月数千円が無駄に引き落とされ続ける**。

* **問題点**  
  * **孤立したEBS：** EC2を削除しても、設定によってはEBSボリュームが残り続け、課金されます。  
  * **未割り当てのElastic IP：** EC2に紐付いていないEIPは課金対象となります。  
  * **古いスナップショット：** 無期限に保存された古いバックアップがストレージ容量を圧迫します。  

* **推奨される構成：ライフサイクル管理と棚卸し**  
  * EC2作成時に「終了時に削除（Delete on Termination）」オプションを有効にします。  
  * タグ付け戦略（コストセンター、所有者、期限）を徹底し、定期的にリソースを棚卸しします。

> **✅ 具体例：**
> *   AWS Config や Trusted Advisor を定期的にチェックし、「使用されていないEIP」や「低使用率のRDS」を一覧化して削除する。

### アンチパターン：リザーブドインスタンス・Savings Plansの未活用

長期間稼働することが確定している本番リソースに対して、オンデマンド料金を支払い続けるケースです。

> **❌ 具体例：**
> *   24時間365日稼働する本番DBに対して、定価（オンデマンド）で毎月支払っている。
> *   **年間で数十万円〜数百万円の割引チャンスを捨てている状態**。

* **問題点**  
  * 定価（オンデマンド）での支払いは、長期的に見て大幅なコストロスとなります。  

* **推奨される構成：Savings Plansの購入**  
  * ベースラインとなる使用量に対して、Savings Plansやリザーブドインスタンスを購入し、最大70%程度のコスト削減を図ります。

> **✅ 具体例：**
> *   「最低でも毎月これくらいは使う」という額（コミットメント）を決めて **Compute Savings Plans** を1年または3年で購入する。
> *   対象のEC2やFargate、Lambdaの料金が自動的に約30〜50%割引される。


