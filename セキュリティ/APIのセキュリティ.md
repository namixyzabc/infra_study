

### OWASP API Security Top 10 2023 で理解する主要な脅威

OWASPは、Webアプリケーションセキュリティに関する啓発活動を行うコミュニティであり、APIに特化したセキュリティ上の脅威トップ10を定期的に公開しています。 2023年版のリストは、現代のAPIが直面する最も重大なリスクを理解する上で非常に有用です。

---

#### **API1:2023 - Broken Object Level Authorization (BOLA) / オブジェクトレベルの認可の不備**

これは、APIに存在する最も一般的で深刻な脆弱性の一つです。 エンドポイントが、ユーザーがアクセス権を持つべきオブジェクト（リソース）にのみアクセスできることを正しく検証していない場合に発生します。

**何が問題か？**
攻撃者は、リクエスト内のオブジェクトID（例：ユーザーID、ファイルIDなど）を別の値に変更するだけで、他人の情報に不正にアクセスしたり、データを改ざんしたりできてしまいます。これはIDOR（Insecure Direct Object References：安全でない直接的なオブジェクト参照）としても知られています。

**具体例：**
あるユーザーが自身のプロフィール情報を取得するAPIリクエストを考えます。
`GET /api/v1/users/12345/profile`

ここで、攻撃者が `12345` の部分を別のユーザーIDである `67890` に書き換えてリクエストを送信したとします。
`GET /api/v1/users/67890/profile`

サーバー側で「リクエストを送信したユーザーが、ID `67890` のプロフィールを閲覧する権限を持っているか」という検証がなければ、攻撃者は他人のプロフィール情報を閲覧できてしまいます。

**脆弱なコード例（Node.js / Express）：**
```javascript
// 脆弱なコード：リクエストされたuser_idのデータを誰にでも返してしまう
app.get('/api/v1/users/:userId/profile', (req, res) => {
  const { userId } = req.params;
  // 認可チェックなしに、DBからユーザー情報を取得
  db.users.findById(userId, (err, user) => {
    if (err || !user) {
      return res.status(404).send('User not found.');
    }
    res.json(user.profile);
  });
});
```

**対策手順とコード例：**
すべてのリクエストにおいて、リソースにアクセスしようとしているユーザーが、そのリソースに対する適切な権限を持っているかを確認する処理を必ず実装します。

```javascript
// 対策後のコード：セッション情報などから自らのIDを取得し、要求されたIDと比較
app.get('/api/v1/users/:userId/profile', (req, res) => {
  const requestedUserId = req.params.userId;
  const loggedInUserId = req.session.userId; // ログイン中のユーザーID

  // ログイン中のユーザーIDと要求されたユーザーIDが一致するかを検証
  if (requestedUserId !== loggedInUserId) {
    // 管理者権限など、特別なロールを持っているかもチェックする
    // if (!req.session.isAdmin) {
      return res.status(403).send('Forbidden: You do not have access to this resource.');
    // }
  }

  db.users.findById(requestedUserId, (err, user) => {
    if (err || !user) {
      return res.status(404).send('User not found.');
    }
    res.json(user.profile);
  });
});
```

また、推測されにくいランダムなID（UUID/GUIDなど）を使用することも、攻撃を困難にする上で有効です。

```

#### **API2:2023 - Broken Authentication / 認証の不備**

認証メカニズムが正しく実装されていない、または脆弱な実装である場合に発生します。これにより、攻撃者が他人のアカウントを乗っ取ることが可能になります。

**何が問題か？**
*   ブルートフォース攻撃（総当たり攻撃）に対する保護がない（レートリミットやアカウントロックアウトの不備）。
*   弱いパスワードが許可されている。
*   セッショントークンやAPIキーがURLに含まれており、ログなどに記録されて漏洩する。
*   JWT（JSON Web Token）の署名検証が行われない、または`alg:none`のような脆弱なアルゴリズムが許可されている。
*   JWTの有効期限が検証されない。

**具体例：JWTの`alg:none`脆弱性**
JWTは、ヘッダー、ペイロード、署名の3部から構成されます。署名は、トークンが改ざんされていないことを保証するために重要です。しかし、一部のライブラリは、署名検証を行わない`alg:none`というアルゴリズムをデバッグ目的で許可していました。攻撃者は、JWTのヘッダーを`{"alg":"none"}`に書き換え、署名部分を空にすることで、署名検証を回避し、ペイロード（例：ユーザーIDや権限）を自由に書き換えてトークンを偽造できてしまいます。

**対策手順：**
*   認証に関する機能は、実績のある標準的なフレームワーク（OAuth 2.0, OpenID Connectなど）を利用し、自前での実装（車輪の再発明）を避けます。
*   ログイン試行回数に制限（レートリミット）を設け、複数回失敗した場合はアカウントを一時的にロックアウトする機能を実装します。
*   強力なパスワードポリシーを強制し、多要素認証（MFA）を導入します。
*   アクセストークンは短命にし、リフレッシュトークンを使用して再発行する仕組みを導入します。
*   JWTを使用する場合、`alg:none`を絶対に許可せず、強力な署名アルゴリズム（例：RS256）を使用し、必ず署名と有効期限を検証します。

```

#### **API3:2023 - Broken Object Property Level Authorization / オブジェクトプロパティレベルの認可の不備**

オブジェクト全体へのアクセスは許可されていても、そのオブジェクト内の特定のプロパティ（フィールド）に対するアクセス制御が不十分な場合に発生します。Mass Assignment（マスアサインメント）脆弱性とも関連が深いです。

**何が問題か？**
APIがクライアントから送信されたデータを無検証でそのままオブジェクトにマッピング（割り当て）してしまうと、攻撃者はリクエストに本来変更すべきでないプロパティ（例：権限フラグ、ステータスなど）を含めることで、自身の権限を昇格させたり、データを不正に操作したりできます。

**具体例：**
ユーザーが自身のプロフィール（例：名前、住所）を更新するAPIを考えます。
`PUT /api/v1/users/me`
リクエストボディ：`{"name": "New Name", "address": "New Address"}`

このAPIが、リクエストボディで送られてきたキーと値をそのままDBのユーザーオブジェクトに反映する実装だった場合、攻撃者は次のようなリクエストを送信する可能性があります。
`PUT /api/v1/users/me`
リクエストボディ：`{"name": "New Name", "isAdmin": true}`

もしユーザーテーブルに`isAdmin`というカラム（管理者かどうかを示すフラグ）が存在した場合、このリクエストによって攻撃者は自身を管理者へと昇格させることができてしまいます。

**脆弱なコード例（Node.js / Mongoose）：**
```javascript
// 脆弱なコード：リクエストボディをそのままモデルに渡してしまう
app.put('/api/v1/users/me', (req, res) => {
  const userId = req.session.userId;
  // req.bodyにはisAdminなどの危険なプロパティが含まれている可能性がある
  User.findByIdAndUpdate(userId, req.body, { new: true }, (err, user) => {
    // ...
    res.json(user);
  });
});
```

**対策手順とコード例：**
APIが受け入れるプロパティを明確に定義し、それ以外のプロパティは無視またはエラーとする「許可リスト（Allowlist）」方式を実装します。 DTO（Data Transfer Object）やスキーマバリデーションライブラリの活用が有効です。

```javascript
// 対策後のコード：更新を許可するプロパティを明示的に指定する
app.put('/api/v1/users/me', (req, res) => {
  const userId = req.session.userId;
  const updateData = {
    name: req.body.name,
    address: req.body.address
    // isAdminやemailなどはここに含まない
  };

  User.findByIdAndUpdate(userId, updateData, { new: true }, (err, user) => {
    // ...
    res.json(user);
  });
});```

```

#### **API4:2023 - Unrestricted Resource Consumption / リソース消費の制限不備**

APIが受け付けるリクエストの数やサイズ、処理の複雑さに制限がない場合、サービス拒否（DoS）攻撃や、サーバーリソースの枯渇を引き起こす可能性があります。

**何が問題か？**
*   **レートリミットの欠如：** 攻撃者が短時間に大量のリクエストを送信し、サーバーをダウンさせる。
*   **ペイロードサイズの制限不備：** 非常に大きなJSONオブジェクトやファイルをアップロードさせ、メモリやCPUを過剰に消費させる。
*   **ページネーションの不備：** `GET /api/v1/items?page=1&size=1000000` のように、一度に大量のデータを要求され、データベースとサーバーに過大な負荷をかける。
*   **クエリの複雑性の制限不備：** GraphQLなどで非常に複雑なクエリを送信され、サーバーリソースを使い果たさせる。

**対策手順：**
*   **レートリミットの実装：** IPアドレス、ユーザーID、APIキー単位で、単位時間あたりのリクエスト数を制限します。
*   **リクエスト/レスポンスサイズの制限：** WebサーバーやAPIゲートウェイで、受け付けるリクエストボディや返すレスポンスの最大サイズを設定します。
*   **ページネーションの制御：** ページサイズにデフォルト値と最大値を設定し、クライアントが要求できる上限を設けます。
*   **タイムアウト設定：** リクエストの処理時間が長すぎる場合、処理を中断してエラーを返すようにタイムアウトを設定します。

```

#### **API5:2023 - Broken Function Level Authorization / 機能レベルの認可の不備**

認証されたユーザーであっても、そのユーザーの役割（例：一般ユーザー、管理者）に応じた機能へのアクセス制御が不十分な場合に発生します。

**何が問題か？**
一般ユーザーが、管理者のみがアクセスできるはずのAPIエンドポイントを直接呼び出すことで、本来許可されていない操作（例：他のユーザーの削除、システム設定の変更）を実行できてしまいます。これは、UI上ではボタンが表示されていなくても、APIエンドポイントのURLを推測して直接リクエストを送ることで攻撃が成立します。

**具体例：**
*   管理者用ユーザー一覧API: `GET /api/v1/admin/users`
*   管理者用ユーザー削除API: `DELETE /api/v1/admin/users/{userId}`

一般ユーザーとしてログインしている攻撃者が、これらのエンドポイントを知り、直接リクエストを送信します。サーバーがリクエストの送信者が管理者であるかどうかのチェックを怠っていると、一般ユーザーが他のユーザーを削除できてしまいます。

**対策手順：**
APIの設計において、明確な権限管理ポリシーを定義し、それを強制するメカニズムを導入します。
1.  **デフォルトで拒否：** まずすべてのアクセスを拒否し、明示的に許可されたものだけを許可する。
2.  **一元的な認可処理：** 各エンドポイントで個別に認可処理を記述するのではなく、ミドルウェアやフレームワークの機能を利用して、一元的にアクセス制御を適用する。
3.  **RBAC（Role-Based Access Control）の導入：** 「管理者」「編集者」「閲覧者」といった役割（Role）を定義し、各役割に許可される操作（Permission）を割り当てます。ユーザーには役割を付与し、APIリクエストのたびに、そのユーザーの役割が必要な権限を持っているかを確認します。

**コード例（ミドルウェアでの役割チェック）：**
```javascript
// 管理者権限が必要なAPIの前に挟むミドルウェア
const requireAdmin = (req, res, next) => {
  // セッションやトークンからユーザー情報を取得
  const user = req.user;
  if (user && user.role === 'admin') {
    next(); // 権限があれば次の処理へ
  } else {
    res.status(403).send('Forbidden: Administrator access required.');
  }
};

// 管理者用APIのエンドポイントにミドルウェアを適用
app.get('/api/v1/admin/users', requireAdmin, (req, res) => {
  // ...管理者向けの処理
});
```

---

#### **API6:2023 - Unrestricted Access to Sensitive Business Flows / 機微なビジネスフローへの無制限なアクセス**

攻撃者が、技術的な脆弱性ではなく、ビジネスロジックそのものを悪用する攻撃です。APIが公開するビジネスフロー（例：商品購入、アカウント登録、パスワードリセット）の仕様を逆手にとります。

**何が問題か？**
*   **買い占め：** チケット販売サイトや限定商品のECサイトで、ボットが購入フローのAPIを高速で実行し、商品を買い占める。
*   **スパム登録：** アカウント作成APIを自動化されたスクリプトで大量に呼び出し、大量のスパムアカウントを作成する。
*   **在庫枯渇攻撃：** 在庫確認APIとカート追加APIを繰り返し呼び出すことで、商品をカートに確保し続け、他のユーザーが購入できないようにする（在庫を枯渇させる）。

**対策手順：**
この種の攻撃は、個々のリクエストが正当に見えるため、従来のセキュリティ対策だけでは検知が困難です。
*   **異常検知：** 同一ユーザーや同一IPアドレスから、短時間に特定のフローが異常な回数実行されていないかを監視します。
*   **CAPTCHAの導入：** アカウント登録や購入確定など、重要なフローの最終段階でCAPTCHAを要求し、ボットによる自動化を困難にします。
*   **デバイスフィンガープリンティング：** ブラウザやデバイスの特性を分析し、人間による操作かボットかを識別する。
*   **ビジネスロジックの見直し：** 例えば、「1ユーザーあたり1つまで」のような購入制限をAPIレベルで厳密に適用します。

---

#### **API7:2023 - Server Side Request Forgery (SSRF) / サーバーサイドリクエストフォージェリ**

APIが外部のURLをパラメータとして受け取り、そのURLにサーバーサイドからリクエストを送信する機能を持つ場合に発生する脆弱性です。

**何が問題か？**
攻撃者が、APIサーバーからしかアクセスできない内部ネットワーク上のサーバーや、クラウドサービスのメタデータサービス（`http://169.254.169.254`など）に対してリクエストを送信させることができます。これにより、内部システムのポートスキャン、機密情報（認証情報など）の窃取、内部サービスへの攻撃などが可能になります。

**具体例：**
指定されたURLのWebサイトのスクリーンショットを生成するAPIがあったとします。
`GET /api/v1/screenshot?url=https://example.com`

攻撃者は`url`パラメータに内部ネットワークのIPアドレスや特別なURLを指定します。
*   `url=http://localhost/server-status` （内部サーバーのステータス情報を窃取）
*   `url=http://169.254.169.254/latest/meta-data/iam/security-credentials/` （AWSのIAMロール認証情報を窃取）

**対策手順：**
*   **許可リスト（Allowlist）による検証：** 最も効果的な対策です。アクセスを許可するドメインやIPアドレスのリストを事前に定義し、リクエストされたURLがそのリストに含まれているか厳密に検証します。
*   **レスポンスの無害化：** 外部から取得したレスポンスをそのままクライアントに返さず、必要な情報のみを抽出・加工して返します。
*   **ネットワークレベルの制御：** APIサーバーがアクセスできるネットワーク範囲をファイアウォールなどで厳しく制限し、不要な内部サーバーや外部への通信を禁止します。

---

#### **API8:2023 - Security Misconfiguration / セキュリティ設定の不備**

安全でないデフォルト設定、不完全またはアドホックな設定、クラウドサービスの不適切な設定、詳細すぎるエラーメッセージなど、広範な設定ミスに起因する脆弱性です。

**何が問題か？**
*   **不要なHTTPメソッドの許可：** `GET`のみを意図したエンドポイントで`PUT`や`DELETE`が許可されている。
*   **CORS (Cross-Origin Resource Sharing) の不適切な設定：** `Access-Control-Allow-Origin: *` のように安易にすべてのオリジンを許可していると、悪意のあるWebサイトからAPIを呼び出され、情報が窃取される可能性がある。
*   **詳細なエラーメッセージ：** 本番環境でスタックトレースやデータベースのエラー情報、内部のパス情報などをレスポンスに含めてしまい、攻撃者に内部構造に関するヒントを与えてしまう。
*   **クラウドストレージの設定ミス：** S3バケットなどが意図せず公開設定になっている。

**対策手順：**
*   **最小権限の原則：** 必要な設定、必要なポート、必要な権限のみを許可し、他はすべて無効化する。
*   **本番環境と開発環境の分離：** 本番環境ではデバッグモードを無効にし、エラーメッセージは汎用的なもの（例：「内部サーバーエラーが発生しました」）に統一する。詳細なエラーはサーバーサイドのログにのみ記録する。
*   **CORSの厳格な設定：** 許可するオリジンを明示的に指定する。
*   **定期的な設定監査：** セキュリティスキャナやクラウドセキュリティポスチャ管理（CSPM）ツールを利用して、設定ミスがないか定期的に監査する。

---

#### **API9:2023 - Improper Inventory Management / 不適切なインベントリ管理**

組織が、本番環境で稼働しているすべてのAPIエンドポイント（特に古いバージョンや開発中のAPI）を正確に把握・管理できていない状態を指します。

**何が問題か？**
*   **シャドーAPI (Shadow APIs)：** 開発者がテスト目的などで作成し、公式な管理下に置かれていないまま放置されたAPI。セキュリティ対策が施されていないことが多い。
*   **ゾンビAPI (Zombie APIs)：** `v1`から`v2`へ移行した後も、古い`v1`のAPIが停止されずに稼働し続けている状態。脆弱性がパッチされないまま放置され、攻撃の標的となる。
*   **ドキュメントとの乖離：** APIドキュメントに記載されていないエンドポイントやパラメータが存在し、テストやセキュリティ監査の対象から漏れる。

**対策手順：**
*   **APIインベントリの作成と維持：** 稼働しているすべてのAPI（ホスト、バージョン、環境、アクセス権限など）を一覧化し、常に最新の状態に保つ。
*   **APIゲートウェイの導入：** すべてのAPIリクエストをAPIゲートウェイ経由に集約することで、トラフィックを可視化し、一元的な管理とセキュリティポリシーの適用を可能にします。
*   **ドキュメントの自動化：** OpenAPI Specification (OAS, 旧Swagger) などを用いてコードからAPIドキュメントを自動生成し、実装とドキュメントの乖離を防ぐ。
*   **定期的なスキャンと棚卸し：** ネットワークをスキャンして未知のAPI（シャドーAPI）を発見し、不要なAPI（ゾンビAPI）を特定して廃止するプロセスを確立する。

---

#### **API10:2023 - Unsafe Consumption of APIs / 安全でないAPIの利用**

これまでの9項目が「提供する側」のセキュリティだったのに対し、この項目は「利用（消費）する側」のセキュリティリスクを指します。サードパーティのAPIと連携する際に発生します。

**何が問題か？**
*   **信頼しすぎる入力：** サードパーティAPIからのレスポンスデータを無検証で自社のシステムに連携することで、インジェクション攻撃やSSRFの踏み台にされる。
*   **クレデンシャルの漏洩：** サードパーティAPIを利用するためのAPIキーや認証情報を、ソースコードにハードコーディングしたり、安全でない方法で保管したりして漏洩させてしまう。
*   **サプライチェーン攻撃：** 利用しているサードパーティAPI自体が侵害され、そこから自社のシステムへ攻撃が波及する。

**対策手順：**
*   **入力値検証の徹底：** 外部APIからのデータも、ユーザーからの入力と同様に信頼せず、厳密にバリデーションとサニタイズを行う。
*   **クレデンシャルの安全な管理：** APIキーなどは環境変数やAWS Secrets Manager, Google Cloud Secret Manager, Azure Key Vaultなどのシークレット管理サービスを利用して安全に保管する。
*   **接続タイムアウトとリトライ処理：** 外部APIの障害が自社サービスのパフォーマンスに影響を与えないよう、適切な接続タイムアウトとサーキットブレーカーパターンなどを実装する。
*   **サードパーティのセキュリティ評価：** 利用するAPIを提供する企業のセキュリティ体制を評価し、信頼できるサービスを選択する。

### OWASP Top 10以外の重要なセキュリティ対策

OWASP API Security Top 10は重要な指針ですが、これ以外にも基本的ながら欠かせない対策があります。

*   **インジェクション攻撃対策：** SQLインジェクション、NoSQLインジェクション、OSコマンドインジェクションなどはAPIにおいても依然として脅威です。ORM（Object-Relational Mapping）やパラメータ化クエリ（プリペアドステートメント）を使い、ユーザーからの入力を安全に処理することが不可欠です。
*   **ロギングとモニタリング：** 誰が、いつ、どのAPIにアクセスし、何をしたか（成功/失敗を含む）を記録することは、インシデントの検知と事後調査のために極めて重要です。 認証失敗、認可エラー、入力バリデーションエラーなどは特に注意深く監視すべきです。
*   **通信とデータの暗号化：** クライアントとサーバー間の通信はすべてTLS（Transport Layer Security）で暗号化し、盗聴や改ざんを防ぎます。 パスワードや個人情報などの機密データは、データベースに保存する際にハッシュ化や暗号化を施します。
*   **APIゲートウェイの活用：** 前述の通り、APIゲートウェイは認証、認可、レートリミット、ロギング、CORS設定などを一元的に担うことで、個々のマイクロサービスのセキュリティ実装の負担を軽減し、ポリシーの統一を容易にします。

### 近年の傾向と新たな脅威への対策

テクノロジーの進化とともに、APIセキュリティの脅威も変化しています。

#### **GraphQL APIのセキュリティ**

RESTに代わるAPIアーキテクチャとして採用が増えているGraphQLには、特有のセキュリティリスクが存在します。

*   **課題：**
    *   **過剰なデータ取得とDoS攻撃：** クライアントがクエリの構造を決められるため、意図的に深くネストされたクエリや循環参照を含むクエリを送信し、サーバーに過大な負荷をかける攻撃が可能です。
    *   **イントロスペクションによる情報漏洩：** GraphQLにはスキーマ（APIの構造）自体を問い合わせる「イントロスペクション」という機能があり、デフォルトで有効になっていると、攻撃者にAPIの全体像や非公開のフィールドに関する情報を与えてしまいます。
*   **対策：**
    *   **クエリの深さ・複雑さの制限：** 許容するクエリのネストの深さや、クエリ全体の複雑度（コスト）に上限を設定します。
    *   **永続化クエリ（Persisted Queries）：** サーバー側で許可されたクエリのみを実行可能にし、任意のクエリの実行を防ぎます。
    *   **本番環境でのイントロスペクション無効化：** 攻撃者に不要な情報を与えないため、本番環境ではイントロスペクション機能を無効化します。
    *   **フィールドレベルでの認可：** オブジェクト全体だけでなく、フィールド単位でアクセス制御を行います。

#### **サーバーレスアーキテクチャとAPIセキュリティ**

AWS LambdaやGoogle Cloud Functionsなどのサーバーレスアーキテクチャは、APIのバックエンドとして多用されますが、これも独自のセキュリティ課題を抱えています。

*   **課題：**
    *   **権限管理の複雑化：** 機能（Function）が細分化されるため、各関数に必要な最小限の権限（IAMロールなど）を適切に管理することが煩雑になります。権限が過剰に付与されると、1つの関数が侵害されただけで被害が拡大する恐れがあります。
    *   **設定ミス：** API Gatewayや各関数のトリガー、環境変数の設定など、設定箇所が多岐にわたるため、意図しない設定ミスが発生しやすくなります。
    *   **イベントインジェクション：** S3イベントやSNS通知など、多様なイベントソースから関数がトリガーされるため、それらのイベントデータに悪意のあるコードが含まれていた場合のインジェクションリスクがあります。
*   **対策：**
    *   **最小権限の原則の徹底：** 各関数には、その機能を実現するために本当に必要な権限のみを付与します。 例えば、特定のS3バケットから読み取るだけの関数には、書き込み権限や他のバケットへのアクセス権を与えません。
    *   **IaC (Infrastructure as Code) の活用：** TerraformやAWS SAM/CDKなどを用いてインフラ構成をコードで管理し、レビュー可能な状態にすることで設定ミスを防ぎます。
    *   **入力データの検証：** すべてのイベントソースからの入力を信頼せず、関数内で厳密に検証します。

#### **自動化された攻撃（ボット）の高度化**

前述のビジネスフローへの攻撃に加え、クレデンシャルスタッフィング（漏洩したID/パスワードリストを使ったログイン試行）やスクレイピングなど、ボットによる自動化された攻撃はますます高度化・巧妙化しています。

*   **対策：**
    *   **WAF/WAAP (Web Application and API Protection) の活用：** シグネチャベースの防御に加え、IPレピュテーション（評価）、ふるまい検知などを用いて、高度なボットを識別・ブロックします。
    *   **ゼロトラスト・アプローチ：** 「信頼せず、常に検証せよ」の原則に基づき、すべてのAPIリクエストを、送信元に関わらず認証・認可します。

### まとめ：実践的なAPIセキュリティ対策の進め方

安全なAPIを構築・運用するためには、開発ライフサイクルの各段階でセキュリティを意識する「シフトレフト」のアプローチが重要です。

1.  **設計段階：**
    *   **脅威モデリング：** APIの機能やデータフローを洗い出し、どのような脅威が存在するかを分析・評価する。
    *   **スキーマ定義：** OpenAPI Specificationなどを用いて、リクエストとレスポンスのデータ構造、認証方式などを厳密に定義する。これがセキュリティテストと実装の基盤となる。
    *   **認証・認可方式の選定：** アプリケーションの要件に合った、堅牢な認証・認可方式（OAuth 2.0など）を選定する。

2.  **実装段階：**
    *   **セキュアコーディング：** 本記事で解説したOWASP API Security Top 10の各項目を念頭に置き、脆弱性を生まないコーディングを実践する。
    *   **フレームワークの活用：** 利用しているフレームワークが提供するセキュリティ機能を最大限に活用する。
    *   **クレデンシャルの管理：** APIキーやパスワードをコードにハードコーディングせず、シークレット管理サービスを利用する。

3.  **テスト段階：**
    *   **静的/動的アプリケーションセキュリティテスト（SAST/DAST）：** CI/CDパイプラインにセキュリティテストツールを組み込み、脆弱性を早期に発見する。
    *   **API特化の脆弱性診断：** BOLAや機能レベルの認可不備など、API特有の脆弱性を専門的にテストする（自動ツールと手動ペネトレーションテストの併用が望ましい）。

4.  **運用段階：**
    *   **防御層の導入：** APIゲートウェイやWAF/WAAPを導入し、多層防御を実現する。
    *   **継続的な監視：** APIのトラフィック、エラーログ、パフォーマンスを常に監視し、異常なアクティビティを迅速に検知できる体制を整える。
    *   **インベントリ管理と棚卸し：** APIインベントリを維持し、不要になったAPIは速やかに廃止するプロセスを定着させる。

