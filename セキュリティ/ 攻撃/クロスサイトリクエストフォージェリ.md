### クロスサイトリクエストフォージェリ（CSRF）解説

クロスサイトリクエストフォージェリ（Cross-Site Request Forgeries、以下CSRF）は、Webアプリケーションの脆弱性を利用した攻撃手法の一つです。 攻撃者は、ユーザーが意図しないリクエストをWebアプリケーションに送信させ、不正な操作を実行させます。 この攻撃は「リクエストの偽造」とも呼ばれ、ユーザーがログインしている状態を悪用する巧妙な手口です。

---

### 1. CSRF攻撃の仕組み

CSRF攻撃は、主に以下の3者の関係で成り立ちます。

*   **攻撃者**: 悪意を持って不正なリクエストを仕込んだWebページ（罠サイト）を用意する人物。
*   **被害者（正規ユーザー）**: 攻撃対象のWebアプリケーションにログインしている一般ユーザー。
*   **脆弱性のあるWebサイト**: CSRF対策が施されていないWebアプリケーション。

攻撃は次のような流れで実行されます。

1.  **ログイン状態の維持**: 被害者は、銀行やSNSなど、目的のWebサイト（正規サイト）にログインします。ブラウザには、そのサイトのログイン状態を維持するためのセッション情報（通常はCookieに保存）が保持されます。
2.  **罠サイトへの誘導**: 攻撃者は、メールやSNS、掲示板などに不正なリンクを貼り、被害者を自身が作成した「罠サイト」へ誘導します。
3.  **不正なリクエストの自動送信**: 被害者が罠サイトを閲覧すると、そこに埋め込まれたスクリプトやHTMLタグが、被害者のブラウザに正規サイトへのリクエストを自動的に送信させます。
4.  **リクエストの誤認と実行**: リクエストを受け取った正規サイトは、被害者のブラウザから自動的に付与されたセッション情報（Cookie）を見て、「正規のユーザーからの正しいリクエスト」であると誤認します。 その結果、パスワードの変更や商品の購入、意図しない投稿など、攻撃者が仕込んだ通りの処理を実行してしまいます。

CSRF攻撃の核心は、ユーザーがログインしている状態を乗っ取り、ユーザー自身の権限で、ユーザーが意図しない操作を強制的に実行させる点にあります。

#### 【図解】CSRF攻撃のシナリオ

```
                 (2) 罠サイトへ誘導
+----------+      (メール、掲示板のURL)     +----------+
|          | ----------------------------> |          |
|  被害者  |                               | 攻撃者   |
| (ユーザー) | <---------------------------- | (罠サイト) |
+----------+      (1) 正規サイトにログイン     +----------+
     |
     | (3) ログイン状態を維持 (Cookie)
     |
     v
+----------+
| 正規サイト |
+----------+
     ^
     | (4) 罠サイトから不正なリクエストが送信される
     |     (ブラウザがCookieを自動添付)
     |
     +-----------------------------------------+
     (5) 正規サイトは正規ユーザーからの指示と誤認し、
         意図しない処理（例：パスワード変更）を実行
```

#### 具体的な攻撃コードの例

CSRF攻撃には、主にGETリクエストを利用する方法とPOSTリクエストを利用する方法があります。

**a) GETリクエストを利用した攻撃**
状態を変更する処理（例：退会処理）が、URLのパラメータだけで実行できてしまう場合に利用されます。攻撃者は、罠サイトに`<img>`タグを埋め込むだけで攻撃が可能です。

```html
<!-- 罠サイトのHTML -->
<p>最新のニュースはこちら！</p>
<!-- ユーザーには見えないが、ブラウザはこの画像URLにアクセスする -->
<img src="http://example.com/unsubscribe?confirm=true" width="1" height="1">
```

被害者がこのページを開くと、ブラウザは`src`属性に指定されたURLの画像を取得しようとリクエストを送信します。このとき、ブラウザは`example.com`のCookieを自動的に添付するため、サイト側は正規ユーザーからの退会リクエストだと誤認し、処理を実行してしまいます。

**b) POSTリクエストを利用した攻撃**
フォームの送信によって重要な処理（例：パスワード変更）が行われるサイトが標的となります。攻撃者は、自動的にフォームを送信するJavaScriptを罠サイトに埋め込みます。

```html
<!-- 罠サイトのHTML -->
<body onload="document.csrf_form.submit()">
  <form name="csrf_form" action="http://example.com/change_password" method="POST">
    <input type="hidden" name="new_password" value="hacked123">
    <input type="hidden" name="confirm_password" value="hacked123">
  </form>
  <p>読み込み中...</p>
</body>
```

被害者がこのページを開くと、`onload`イベントによってページ読み込みと同時に隠しフォームが自動的に送信（サブミット）されます。このリクエストにもCookieが添付されるため、意図せずパスワードが変更されてしまいます。

---

### 2. CSRF攻撃による具体的な被害

CSRF攻撃が成功すると、ユーザーがログインしているサービスで実行可能なあらゆる操作を悪用される可能性があります。

*   **アカウント情報の不正な変更**: パスワードやメールアドレス、住所などが勝手に変更され、アカウント乗っ取りの足がかりにされる。
*   **意図しない情報発信**: SNSや掲示板で、身に覚えのない内容（誹謗中傷や犯罪予告など）を投稿させられる。 実際に、CSRF攻撃によって掲示板に犯罪予告が書き込まれ、ユーザーが誤認逮捕される事件も発生しています。
*   **不正な金銭的取引**: オンラインバンキングで不正に送金されたり、ECサイトで勝手に商品を購入されたりする。
*   **サービスからの強制退会**: 登録しているWebサービスから意図せず退会させられる。
*   **情報漏洩**: 機密情報を扱う社内システムなどで攻撃が成功した場合、企業の機密情報が漏洩するリスクもあります。

これらの被害は、ユーザーが気づかないうちに行われるため、発見が遅れがちになるという厄介な特徴があります。

---

### 3. CSRF攻撃が成立する前提条件

CSRF攻撃が成功するには、以下の条件が揃う必要があります。

*   被害者が攻撃対象のWebサイトに**ログインしている状態**であること。
*   被害者のブラウザに、正規サイトの有効な**セッション情報（Cookie）が保存されている**こと。
*   攻撃対象のWebサイトに、**CSRF対策が実装されていない**こと。
*   状態を変更するリクエストに、**推測不可能なパラメータが含まれていない**こと。

---

### 4. CSRF対策（Webサイト開発者向け）

CSRF攻撃を防ぐためには、Webアプリケーション側でリクエストの正当性を検証する仕組みを導入することが不可欠です。

#### 4.1. 【最重要】CSRFトークンの利用（Synchronizer Token Pattern）

最も一般的で効果的な対策が、**CSRFトークン**（ワンタイムトークンとも呼ばれる）を利用する方法です。

**仕組み**:
1.  **トークン生成と保存**: ユーザーがフォームなどを表示する際、サーバー側で推測困難なランダムな文字列（CSRFトークン）を生成し、サーバーのセッション情報に保存します。
2.  **フォームへの埋め込み**: 生成したトークンを、HTMLの`<form>`内に`<input type="hidden">`として埋め込み、クライアントに送信します。
3.  **トークンの検証**: ユーザーがフォームを送信すると、リクエストと一緒にトークンがサーバーに送られます。サーバーは、送られてきたトークンとセッションに保存しておいたトークンを比較します。
4.  **処理の実行/拒否**: 両者が一致すれば正規のリクエストと判断して処理を実行し、一致しなければ不正なリクエストとして処理を拒否します。

攻撃者はセッションに保存された正規のトークンを知ることができないため、偽造したリクエストを送信しても検証を突破できません。

**PHPでの実装例**:
CSRFトークンの生成から検証までの一連の流れをPHPで実装する例です。

**① トークンを生成し、フォームに埋め込む (`form.php`)**
```php
<?php
session_start();

// 推測困難なトークンを生成
if (!isset($_SESSION['csrf_token'])) {
    // PHP 7以降で推奨される安全なランダムバイト生成関数
    $_SESSION['csrf_token'] = bin2hex(random_bytes(32));
}
$token = $_SESSION['csrf_token'];
?>

<!DOCTYPE html>
<html>
<head>
    <title>設定変更フォーム</title>
</head>
<body>
    <form action="update.php" method="POST">
        <!-- 隠しフィールドにCSRFトークンを埋め込む -->
        <input type="hidden" name="csrf_token" value="<?php echo htmlspecialchars($token, ENT_QUOTES, 'UTF-8'); ?>">

        <label for="email">新しいメールアドレス:</label>
        <input type="email" id="email" name="email">
        <button type="submit">更新</button>
    </form>
</body>
</html>
```
*   `random_bytes()`で暗号学的に安全なランダムな値を生成し、`bin2hex()`で16進数文字列に変換しています。
*   生成したトークンはサーバー側のセッション（`$_SESSION`）に保存します。

**② 送信されたトークンを検証する (`update.php`)**
```php
<?php
session_start();

// POSTリクエストかどうかを確認
if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
    die('不正なリクエストです。');
}

// トークンの存在と一致を確認
if (!isset($_POST['csrf_token']) || !isset($_SESSION['csrf_token']) || !hash_equals($_SESSION['csrf_token'], $_POST['csrf_token'])) {
    // トークンが一致しない場合は処理を中断
    die('不正な操作が検出されました。');
}

// トークンが正当であれば、古いトークンを破棄して新しいトークンを生成する（任意だが推奨）
unset($_SESSION['csrf_token']);

// --- ここから正規の処理 ---
$new_email = $_POST['email'];
// データベース更新処理など
echo "メールアドレスが更新されました。";
// --- ここまで正規の処理 ---
?>
```
*   `hash_equals()`関数は、文字列の比較を「タイミング攻撃」に対して安全な方法で行うため、トークン比較の際に使用することが強く推奨されます。

#### 4.2. SameSite属性の利用

Cookieの`SameSite`属性は、異なるサイト（クロスサイト）からのリクエスト時にCookieを送信するかどうかを制御する仕組みです。 これを設定することで、多くのCSRF攻撃をブラウザレベルで防ぐことができます。

`SameSite`属性には3つの値を設定できます。

*   **`Strict`**: 最も厳格な設定です。Cookieは、完全に同一のサイトからのリクエストでのみ送信されます。別サイトからリンクを辿って遷移した場合でもCookieは送信されないため、セキュリティは非常に高いですが、ユーザーの利便性が損なわれることがあります。
*   **`Lax`**: `Strict`よりも少し緩やかな設定です。`<a>`タグによる画面遷移や`<form method="GET">`など、一部の安全と見なされるトップレベルのナビゲーションではクロスサイトでもCookieが送信されます。POSTリクエストや`<img>`、`<iframe>`などでは送信されないため、多くのCSRF攻撃に有効です。**近年の主要なブラウザでは、この`Lax`がデフォルト値となっています。**
*   **`None`**: 従来通りの挙動で、クロスサイトリクエストでも常にCookieを送信します。この値を設定する場合、同時に`Secure`属性（HTTPS通信でのみCookieを送信する設定）を付与することが必須となります。

**設定方法（PHPの例）**:
`Set-Cookie`ヘッダーまたは`setcookie()`関数で指定します。
```php
// PHPでSameSite属性を設定する例
$cookie_options = [
    'expires' => time() + 86400,
    'path' => '/',
    'domain' => 'example.com',
    'secure' => true,      // HTTPSを推奨
    'httponly' => true,    // JavaScriptからのアクセスを禁止
    'samesite' => 'Lax'    // または 'Strict'
];
setcookie('session_id', 'your_session_value', $cookie_options);
```
`SameSite=Lax`がデフォルトになったことで、GETリクエストを利用する単純なCSRF攻撃は大幅に減少しました。しかし、POSTリクエストを利用する攻撃や、`Lax`が許容する一部のケースでは依然としてリスクが残るため、CSRFトークンとの併用が推奨されます。

#### 4.3. 重要な操作の前に再認証を要求する

パスワードの変更、メールアドレスの変更、退会、高額な商品の購入など、特にクリティカルな操作を実行する直前に、ユーザーに再度パスワードの入力を求めることも非常に有効な対策です。 たとえCSRF攻撃によってリクエストが偽造されても、攻撃者はユーザーのパスワードを知らないため、この最終関門を突破することができません。

#### 4.4. Refererヘッダーの検証

Refererヘッダーは、リクエストがどのページから送られてきたかを示す情報です。この値を確認し、自サイトのドメイン以外からのリクエストを拒否することで、不正なサイトからのリクエストをブロックできます。

**問題点**:
*   ユーザーのプライバシー設定やセキュリティソフトによって、Refererヘッダーが送信されない場合がある。
*   Refererは技術的に偽装される可能性がある。

これらの理由から、Refererの検証は補助的な対策として位置づけ、これ単体でCSRF対策が完了したと見なすべきではありません。

---

### 5. フレームワークにおけるCSRF対策

現代の主要なWebアプリケーションフレームワーク（Ruby on Rails, Django, Laravel, Flaskなど）には、標準でCSRF対策機能が組み込まれています。これらのフレームワークを利用する場合、開発者は機能を有効にし、正しく利用することで、比較的容易に安全なアプリケーションを構築できます。

*   **Laravel (PHP)**: デフォルトで有効。Bladeテンプレートで`@csrf`ディレクティブをフォーム内に記述するだけで、自動的にトークンが埋め込まれます。
*   **Ruby on Rails**: デフォルトで有効。`form_with`などのフォームヘルパーが自動的にトークンを埋め込みます。
*   **Django (Python)**: デフォルトで有効。テンプレートで`{% csrf_token %}`タグをフォーム内に記述します。

フレームワークのドキュメントに従い、これらの機能を無効化することなく正しく利用することが重要です。

---

### 6. 近年の傾向と発展的なトピック

#### 6.1. JSON APIとCSRF

SPA（Single Page Application）の普及に伴い、サーバーはJSON形式でデータを返すAPIを提供することが増えました。このようなAPIにおけるCSRF対策には、いくつかの特徴があります。

*   伝統的な`<form>`による攻撃は、`Content-Type: application/json`のリクエストを直接生成できないため、そのままでは通用しません。
*   しかし、JavaScript（`fetch`や`XMLHttpRequest`）を使えばJSON形式のリクエストを生成できるため、XSS脆弱性などと組み合わせられると攻撃が可能になります。

**対策**:
JSON APIのCSRF対策としては、「**カスタムリクエストヘッダー**」を利用する方法が一般的です。
1.  クライアント（SPA）は、APIリクエストを送信する際に、`X-CSRF-Token`のような独自のHTTPヘッダーを付与します。
2.  サーバー側は、このヘッダーが存在し、かつ正しい値を持っているかを検証します。

ブラウザの同一オリジンポリシーにより、異なるオリジンからカスタムヘッダーを付与したリクエストを送信することは、通常CORS（Cross-Origin Resource Sharing）の設定で許可されていない限りブロックされます。これにより、罠サイトからの単純なリクエストを防ぐことができます。

#### 6.2. ログインCSRF (Login CSRF)

通常のCSRFとは逆に、**攻撃者が用意したアカウント情報で被害者を強制的にログインさせる**攻撃です。被害者は気づかないうちに攻撃者のアカウントでサービスを利用することになり、その行動履歴（購入履歴や閲覧履歴など）が攻撃者に筒抜けになってしまいます。

対策としては、ログイン処理時にもCSRFトークンを検証することが有効です。

#### 6.3. AIとCSRF

近年、AIを搭載したWebアプリケーションが増加しており、AIチャットボットへのプロンプト送信フォームや、AIの学習データをアップロードする機能などが、CSRF攻撃の新たな標的となる可能性が指摘されています。 これらの機能が重要な処理と連携している場合、意図しないプロンプトの送信や不正な学習データのアップロードといった被害が想定されるため、従来のWebアプリケーションと同様に厳格なCSRF対策が不可欠です。

---

### 7. ユーザー（利用者）側でできる対策

Webサイト開発者側の対策が最も重要ですが、ユーザー側でも以下の点に注意することでリスクを低減できます。

*   **利用後のログアウト**: Webサービスを利用し終わったら、こまめにログアウトする。
*   **不審なリンクを開かない**: メールやSNSに記載されたURLを安易にクリックしない。
*   **ブラウザやセキュリティソフトを最新の状態に保つ**: ブラウザのセキュリティ機能（SameSite属性の適用など）を最大限に活用する。

---

### 8. まとめ

CSRFは、ユーザーがログインしているという信頼を悪用する巧妙な攻撃です。その被害は、意図しない投稿といった軽微なものから、アカウント乗っ取りや金銭的被害といった深刻なものまで多岐にわたります。

Webアプリケーションを開発する上で、CSRF対策は必須のセキュリティ要件です。最も確実な対策は、**CSRFトークンを実装**し、リクエストの正当性をサーバー側で検証することです。 これを基本とし、ブラウザのセキュリティ機能である**SameSite属性の適切な設定**や、重要な操作の前には**パスワードによる再認証**を求めるなど、多層的な防御（Defense in Depth）を講じることが理想的です。

