

### 1. DLLおよびプロセスの前提知識

DLLインジェクションを理解するためには、まずDLLとWindowsのプロセス管理に関する基本的な知識が必要です。

#### DLLとは？

DLL（Dynamic Link Library）は、様々なプログラムから共通して利用される関数やリソースをまとめたファイルです。 例えば、「ファイルを開く」「ウィンドウを表示する」といった基本的な機能は、OSが提供するDLLに含まれており、多くのアプリケーションがこれを共有して利用しています。

DLLを利用する「動的リンク」には、以下の利点があります。

*   **リソースの節約**: 複数のプログラムが同じDLLをメモリ上で共有するため、メモリ使用量やディスク容量を節約できます。
*   **モジュール性**: 機能ごとにDLLを分割することで、開発やメンテナンスが容易になります。特定の機能を更新する際に、DLLファイルだけを置き換えればよく、アプリケーション全体を再コンパイルする必要がありません。
*   **再利用性**: 一度作成したDLLは、異なるアプリケーションからでも呼び出して利用できます。

#### プロセスの仮想アドレス空間

Windowsでは、各プロセスは独立した「仮想アドレス空間」を持っています。 これは、各プロセスがOSから割り当てられた広大なメモリ空間を独占しているかのように振る舞える仕組みです。実際には、物理的なメモリ（RAM）は限られているため、OSが必要に応じて仮想アドレスと物理アドレスを対応付け（マッピング）しています。

この仕組みにより、あるプロセスが他のプロセスのメモリ空間に直接アクセスすることは、原則としてできません。 これがプロセスの独立性と安定性を保つための基本的なセキュリティ機構です。DLLインジェクションは、この原則を乗り越え、他のプロセスのメモリ空間に介入する技術と言えます。

### 2. DLLインジェクションの基本的な仕組み

DLLインジェクションは、いくつかのWindows APIを特定の順序で呼び出すことで実現されます。最も古典的で代表的な手法は、`CreateRemoteThread`と`LoadLibrary`を組み合わせるものです。

基本的な手順は以下の通りです。

1.  **ターゲットプロセスの特定とハンドルの取得**: まず、インジェクション対象となるプロセス（ターゲットプロセス）を探し、`OpenProcess` APIを使用してそのプロセスのハンドルを取得します。ハンドルは、以降の操作でプロセスを識別するための「整理券」のようなものです。
2.  **ターゲットプロセス内でのメモリ確保**: `VirtualAllocEx` APIを使用し、ターゲットプロセスの仮想アドレス空間内に、これから書き込むDLLのパス文字列を格納するためのメモリ領域を確保します。
3.  **DLLパスの書き込み**: `WriteProcessMemory` APIを使い、確保したメモリ領域に、インジェクションしたいDLLのフルパスを書き込みます。
4.  **リモートスレッドの作成と実行**: `CreateRemoteThread` APIを呼び出し、ターゲットプロセス内で新しいスレッドを生成します。 このとき、スレッドの開始アドレスとして`LoadLibrary`関数のアドレスを、引数として先ほど書き込んだDLLパスのアドレスを指定します。
5.  **インジェクションの完了**: ターゲットプロセス内で起動した新しいスレッドが`LoadLibrary`関数を実行し、指定されたパスのDLLを自身のプロセス空間に読み込みます。DLLが読み込まれると、そのDLLのエントリーポイントである`DllMain`関数が実行され、インジェクションは成功となります。

なぜこれが可能なのでしょうか。`kernel32.dll`というWindowsの根幹をなすDLLは、ほとんど全てのプロセスで同じ仮想アドレスにロードされる特性があります。 そのため、攻撃者のプロセスで取得した`LoadLibrary`関数のアドレスは、ターゲットプロセスでも（多くの場合）有効です。この性質を利用して、あたかもターゲットプロセス自身がDLLをロードするよう仕向けることができるのです。

### 3. DLLインジェクションの目的

DLLインジェクションは「諸刃の剣」であり、その目的は多岐にわたります。

#### 悪意のある目的

サイバー攻撃において、DLLインジェクションは極めて有用なツールです。

*   **マルウェアの隠蔽（ステルス化）**: `svchost.exe`（Windowsの正規サービスプロセス）や`explorer.exe`（エクスプローラー）といった信頼されたプロセスにマルウェア本体（DLL）をインジェクトすることで、アンチウイルスソフトのスキャンやユーザーの監視を逃れようとします。 プロセスリストを見ても、怪しいプロセス名は見当たらず、正規のプロセスが動作しているようにしか見えません。
*   **権限昇格と情報窃取**: ターゲットのプロセスが持つ権限やメモリ空間へのアクセス権を悪用します。 例えば、ブラウザのプロセスにインジェクトすれば、入力されたIDやパスワード、Cookie情報を盗み見ることが可能です。
*   **セキュリティソフトの無効化**: セキュリティソフトのプロセスにコードをインジェクトし、その機能を内部から停止させることで、さらなる攻撃活動を容易にします。
*   **オンラインゲームでのチート行為**: ゲームのプロセスにインジェクトし、ゲーム内のパラメータ（体力、スコアなど）を不正に改ざんしたり、通常では見えないプレイヤーの位置を表示させたりします（ウォールハック）。

#### 正当な目的

一方で、DLLインジェクションは悪意のない、正当な目的でも利用されます。

*   **デバッグと解析**: 特定のアプリケーションが内部でどのように動作しているかを調査するため、API呼び出しをフック（横取り）してログを記録する際に使用されます。
*   **機能拡張（カスタマイズ）**: 開発元が意図していない機能を追加するプラグインやアドオンを作成する際に用いられることがあります。例えば、特定のアプリケーションのUIをカスタマイズしたり、新しい機能を追加したりします。
*   **パフォーマンス監視**: アプリケーションのパフォーマンスを計測するために、関数の実行時間などを外部から監視するツールで使用されます。
*   **相互運用性**: 異なるフレームワークで書かれたアプリケーション間で、本来互換性のない機能を連携させるために使われることもあります。

### 4. 主要なDLLインジェクションの手法

DLLインジェクションには様々な手法が存在し、攻撃者は検知を回避するために、より高度で隠密性の高いテクニックを開発し続けています。

#### CreateRemoteThread and LoadLibrary

前述した最も古典的で基本的な手法です。 理解しやすく実装も比較的容易ですが、`CreateRemoteThread`というAPIの呼び出し自体がセキュリティソフトによって監視されやすく、検知されやすいという弱点があります。

**実践的なコード例（C++の疑似コード）**

以下は、この手法の処理の流れを示す疑似コードです。
※注意: このコードは教育目的であり、悪用を推奨するものではありません。

```cpp
#include <windows.h>
#include <iostream>

int main(int argc, char* argv[]) {
    if (argc != 3) {
        std::cerr << "Usage: " << argv[0] << " <PID> <DLL_PATH>" << std::endl;
        return 1;
    }

    DWORD processID = std::atoi(argv[1]);
    const char* dllPath = argv[2];

    // 1. ターゲットプロセスのハンドルを取得
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processID);
    if (hProcess == NULL) {
        std::cerr << "Failed to open target process. Error: " << GetLastError() << std::endl;
        return 1;
    }

    // 2. ターゲットプロセス内にDLLパスを書き込むためのメモリを確保
    LPVOID pDllPathAddress = VirtualAllocEx(hProcess, NULL, strlen(dllPath) + 1, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (pDllPathAddress == NULL) {
        std::cerr << "Failed to allocate memory in target process. Error: " << GetLastError() << std::endl;
        CloseHandle(hProcess);
        return 1;
    }

    // 3. 確保したメモリにDLLのパスを書き込む
    BOOL written = WriteProcessMemory(hProcess, pDllPathAddress, dllPath, strlen(dllPath) + 1, NULL);
    if (!written) {
        std::cerr << "Failed to write DLL path to target process. Error: " << GetLastError() << std::endl;
        VirtualFreeEx(hProcess, pDllPathAddress, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return 1;
    }

    // 4. LoadLibraryA関数のアドレスを取得
    LPVOID pLoadLibraryA = (LPVOID)GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "LoadLibraryA");
    if (pLoadLibraryA == NULL) {
        std::cerr << "Failed to get LoadLibraryA address." << std::endl;
        // ... (cleanup)
        return 1;
    }

    // 5. ターゲットプロセスでLoadLibraryAを呼び出すリモートスレッドを作成
    HANDLE hRemoteThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pLoadLibraryA, pDllPathAddress, 0, NULL);
    if (hRemoteThread == NULL) {
        std::cerr << "Failed to create remote thread. Error: " << GetLastError() << std::endl;
        // ... (cleanup)
        return 1;
    }

    std::cout << "Injection successful." << std::endl;

    // 後処理
    WaitForSingleObject(hRemoteThread, INFINITE);
    CloseHandle(hRemoteThread);
    VirtualFreeEx(hProcess, pDllPathAddress, 0, MEM_RELEASE);
    CloseHandle(hProcess);

    return 0;
}
```

#### Windowsフック (SetWindowsHookEx)

`SetWindowsHookEx` APIを利用する手法です。 このAPIは、キーボード入力やマウス操作といったシステム全体のイベント（フック）を監視するために使われます。特定のイベントを監視するフックプロシージャをDLL内に実装し、このAPIでシステムに登録することで、イベントが発生した際にOSが自動的に対象プロセスのメモリ空間にそのDLLをロードします。 `CreateRemoteThread` を直接呼び出さないため、検知を回避しやすい場合があります。

#### レジストリを利用した手法 (AppInit_DLLs)

Windowsのレジストリキー `AppInit_DLLs` にDLLのパスを登録しておくことで、`User32.dll`をロードする全てのプロセス（つまり、ほとんどのGUIアプリケーション）が起動時にそのDLLを自動的に読み込むようにする手法です。システム全体に広範囲な影響を及ぼせる強力な手法でしたが、セキュリティリスクが高いため、近年のWindows OSではセキュアブートが有効な環境では無効化されるなど、その機能は大幅に制限されています。

#### APCインジェクション (Asynchronous Procedure Call)

スレッドの「非同期プロシージャコール（APC）」キューを悪用する、より高度で隠密性の高い手法です。 実行中のスレッドが待機状態（Alertable State）になったタイミングで、あらかじめキューに登録しておいた任意のコード（DLLをロードするコード）を実行させます。 `CreateRemoteThread`のように新しいスレッドを生成しないため、スレッド生成を監視するセキュリティ製品による検知を回避できる可能性があります。

#### プロセスホーローイング (Process Hollowing)

厳密にはDLLインジェクションとは異なりますが、関連性の高いプロセスインジェクション技術です。

1.  まず、正規のプロセスを「一時停止（Suspended）」状態で起動します。
2.  `NtUnmapViewOfSection` などのAPIを使い、そのプロセスのメモリ空間から正規のコードをアンマップ（除去）し、空洞（Hollow）の状態にします。
3.  空になったメモリ空間に、悪意のあるコード（マルウェア本体）を書き込みます。
4.  プロセスの実行を再開（Resume）させます。

結果として、プロセスリスト上は正規のプロセス（例: `svchost.exe`）が実行されているように見えますが、その実体は完全にマルウェアに入れ替わっています。検知が非常に困難な手法の一つです。

#### リフレクティブDLLインジェクション (Reflective DLL Injection)

最も高度な手法の一つで、ファイルレスマルウェアで多用されます。 この手法の最大の特徴は、**インジェクトするDLLファイルをディスクに書き込む必要がない**ことです。

通常のDLLインジェクションでは、`LoadLibrary`がDLLファイルをディスクから読み込み、メモリへのマッピングやインポート関数のアドレス解決といったロード処理をOS（PEローダー）に任せます。

一方、リフレクティブDLLインジェクションでは、攻撃者自身が実装した最小限のPEローダー機能を持つコード（リフレクティローダー）をDLLに含めておきます。 攻撃者はDLLのバイナリイメージを直接ターゲットプロセスのメモリに書き込み、何らかの方法でリフレクティローダーに実行を移します。すると、リフレクティローダーがメモリ上で自分自身のヘッダを解析し、自分自身を正しくメモリに再配置し、必要なAPIアドレスを解決して`DllMain`を呼び出します。

`LoadLibrary`を介さず、ディスク上にファイルも残らないため、ファイルベースのスキャンやAPI呼び出しの監視を回避するのに非常に効果的です。

### 5. DLLインジェクションの検知と対策

DLLインジェクションへの対策は、一般ユーザー・管理者、開発者、セキュリティ専門家それぞれの立場で行うべきことが異なります。

#### 利用者・管理者向けの対策

1.  **OSとソフトウェアの最新化**: OSやアプリケーションの脆弱性を利用してインジェクションが行われることがあるため、セキュリティパッチを適用し、常に最新の状態を保つことが基本かつ最も重要です。
2.  **信頼できないソフトウェアの実行禁止**: 出所が不明なフリーソフトや怪しいメールの添付ファイルなどは実行しないように徹底します。
3.  **セキュリティソフトの導入と更新**: 最新の脅威に対応したアンチウイルスソフトやEDR（Endpoint Detection and Response）製品を導入し、定義ファイルを常に最新の状態に保ちます。振る舞い検知機能を持つ製品は、未知のインジェクション攻撃を検知する上で有効です。
4.  **権限の最小化**: 日常的な作業を管理者（Administrator）権限で行うのをやめ、標準ユーザー権限でPCを使用します。これにより、万が一マルウェアに感染した場合でも、システム全体への影響を低減できます。

#### 開発者向けの対策

1.  **ASLR (Address Space Layout Randomization) の有効化**: ASLRは、プログラムが実行されるたびにDLLや実行ファイルのベースアドレスをランダムに変更する仕組みです。これにより、攻撃者が`LoadLibrary`などの関数のアドレスを事前に特定することが難しくなります。現代のコンパイラではデフォルトで有効になっています。
2.  **コード署名の利用**: 自社で開発したDLLや実行ファイルには、正規のものであることを証明するためのデジタル署名を付与します。 アプリケーション側で、ロードするDLLの署名を検証する仕組みを導入することで、不正なDLLのロードを防ぐことができます。
3.  **DLL検索順序のハイジャック対策**: `LoadLibrary`をファイル名だけで呼び出すと、OSは特定の順序でDLLを検索します。 攻撃者はこの検索パス上に同名の悪性DLLを配置してハイジャックを狙うことがあります。これを防ぐため、DLLをロードする際は必ずフルパスを指定するか、`SetDllDirectory` APIなどで検索パスを安全な場所に限定することが推奨されます。

#### セキュリティ専門家向けの検知方法

DLLインジェクションを検知するには、多角的なアプローチが必要です。

*   **異常なモジュールのロード監視**: `explorer.exe`や`lsass.exe`のような通常のプロセスが、通常はロードしないはずの不審なDLLや、署名のないDLLをロードしていないか監視します。Process Explorerなどのツールで、各プロセスにロードされているDLLの一覧を確認できます。
*   **メモリフォレンジック**: プロセスのメモリダンプを解析し、不正にインジェクトされたコードの断片や、正規のデータ構造（PEBなど）に加えられた改変の痕跡を探します。リフレクティブDLLインジェクションのようにディスクに痕跡を残さない攻撃の検出に有効です。
*   **API呼び出しの監視**: EDR製品などを活用し、`CreateRemoteThread`、`WriteProcessMemory`、`QueueUserAPC`といったインジェクションに利用されやすいAPIの呼び出しパターンを監視します。特に、正規のプロセスから別のプロセスに対してこれらのAPIが呼び出される場合は注意が必要です。
*   **不審なネットワーク通信**: 正規のプロセス（例：Webブラウザ以外）から、外部の不審なC2（Command and Control）サーバーへの通信が発生していないかを監視します。インジェクトされたマルウェアが外部と通信している可能性があります。

### 6. 近年の傾向

サイバー攻撃者と防御側の「いたちごっこ」は続いており、DLLインジェクションの手法も日々進化しています。

#### ファイルレスマルウェアの隆盛

近年の顕著なトレンドは、リフレクティブDLLインジェクションやプロセスホーローイングを悪用した**ファイルレスマルウェア**の増加です。 これらの攻撃は、実行ファイルをディスク上に残さず、メモリ上のみで活動するため、従来のファイルベースのアンチウイルスソフトでは検知が極めて困難です。

#### LOLBins (Living Off The Land Binaries) の悪用

攻撃者は、わざわざ自身の攻撃ツールを持ち込む代わりに、Windowsに標準で搭載されている正規のツールを悪用して攻撃を行います。 これを「環境寄生型攻撃（Living Off the Land）」と呼び、その際に悪用される正規の実行ファイルを「LOLBins」と呼びます。

例えば、`rundll32.exe`は、DLL内の特定の関数を呼び出すための正規ツールですが、これを悪用して不正なDLLをロードさせることができます。 他にも、`PowerShell.exe`や`mshta.exe`などが頻繁に悪用されます。 これらは正規のツールであるため、セキュリティ製品の監視リストから除外されている場合があり、攻撃活動が検知されにくくなります。

#### EDR (Endpoint Detection and Response) との攻防

従来のアンチウイルスソフトに代わり、エンドポイント（PCやサーバー）の挙動を常時監視し、脅威を検知・対応するEDR製品が普及しています。EDRは、不審なプロセスの生成やAPI呼び出しシーケンスを監視することで、DLLインジェクションを検知しようとします。

これに対抗するため、攻撃者はAPCインジェクションや、さらに高度な「スレッドレスインジェクション」と呼ばれる、新たなスレッドを生成せずに正規のスレッドの処理を乗っ取る手法など、EDRの検知ロジックを回避するための技術を開発しています。

### まとめ

DLLインジェクションは、プロセスにコードを注入するという単純な概念でありながら、その実現方法と目的は非常に多岐にわたる奥深い技術です。正当なソフトウェア開発の現場で役立つツールであると同時に、サイバー攻撃の世界では最も基本的かつ強力な武器の一つとして、今なお広く利用されています。

攻撃者は検知を逃れるために、ファイルレス化やLOLBinsの悪用といった手法を駆使し、ますます巧妙化しています。これに対抗するためには、単一の対策に頼るのではなく、OSの最新化、権限管理といった基本的な衛生管理に加え、EDRのような先進的なセキュリティソリューションの導入、そしてメモリフォレンジックのような高度なインシデント対応能力を組み合わせた、多層的な防御戦略が不可欠です。DLLインジェクションの仕組みを理解することは、現代のサイバーセキュリティを理解する上で極めて重要と言えるでしょう。
