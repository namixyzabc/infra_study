### HTTPヘッダインジェクション解説

HTTPヘッダインジェクションは、Webアプリケーションの脆弱性を利用したサイバー攻撃の一種です。攻撃者は、Webアプリケーションが生成するHTTPレスポンスヘッダに、不正な文字列を「注入（インジェクション）」することで、様々な悪意のある動作を引き起こします。

この攻撃は、改行コード（CRLF）を悪用することから「CRLFインジェクション」とも呼ばれます。 Webアプリケーション開発者だけでなく、サイト運営者にとっても理解しておくべき重要な脅威の一つです。

---

### 1. HTTPヘッダインジェクションの仕組み

#### 1.1. HTTP通信の基本
Webサイトを閲覧する際、私たちのブラウザ（クライアント）とWebサーバーは、HTTP（HyperText Transfer Protocol）というプロトコルで通信しています。

1.  **HTTPリクエスト**：ブラウザがWebサーバーに「このページが見たい」と要求します。
2.  **HTTPレスポンス**：Webサーバーがブラウザに「はい、どうぞ」と要求されたWebページのデータを返します。

このHTTPレスポンスは、大きく分けて「ヘッダ部」と「ボディ部」で構成されています。

*   **ヘッダ (Header)**：レスポンスに関する付加情報（ステータスコード、コンテンツの種類、Cookie情報など）が記述されます。各ヘッダは改行によって区切られます。
*   **ボディ (Body)**：ブラウザに実際に表示されるHTMLなどのコンテンツ本体です。

ヘッダとボディは、**連続した改行（空行）**によって明確に区切られるというルールがあります。

#### 1.2. インジェクション（注入）が発生する原因
HTTPヘッダインジェクションは、Webアプリケーションが**ユーザーからの入力値を適切に処理せずに、そのままHTTPレスポンスヘッダに含めてしまう**ことが原因で発生します。

例えば、URLのパラメータやフォームの入力値などを、リダイレクト先のURLを指定する`Location`ヘッダや、ユーザー情報を保存する`Set-Cookie`ヘッダにそのまま使用するような実装が脆弱性の原因となります。

攻撃者は、この入力値に「改行コード（CRLF）」を意図的に含ませます。 HTTPの仕様では、改行はヘッダの区切りを意味するため、アプリケーションがこの改行コードを無害化せずにヘッダに出力してしまうと、攻撃者は本来のヘッダを終了させ、新たなヘッダやボディ部を不正に追加（注入）することが可能になります。

**URLエンコードにおける改行コード:**
URL内で特殊文字を扱うために、URLエンコードという仕組みが使われます。改行コードは以下のようにエンコードされます。
*   **CR (Carriage Return, \r)**: `%0d`
*   **LF (Line Feed, \n)**: `%0a`

攻撃者は、これらの文字列をパラメータに含めることで、HTTPヘッダインジェクションを試みます。

---

### 2. HTTPヘッダインジェクションによる脅威と攻撃例

この脆弱性が存在すると、攻撃者は以下のような様々な攻撃を仕掛けることが可能になります。

#### 2.1. 任意のCookieの挿入（セッション固定攻撃）

攻撃者が、ユーザーのブラウザに任意のCookie情報を設定する攻撃です。特に、セッションIDを管理するCookieを固定化する「セッション固定（Session Fixation）攻撃」に悪用されると、深刻な被害に繋がる可能性があります。

**攻撃シナリオ:**

1.  **脆弱性のあるサイト**: ユーザーが入力した名前をCookieに保存する機能を持つサイトがあるとします。
    *   URL例: `http://example.com/login.php?name=Taro`
    *   このとき、サーバーは `Set-Cookie: name=Taro` というヘッダを返します。

2.  **攻撃**: 攻撃者は、改行コードと不正な`Set-Cookie`ヘッダを含むURLを作成し、被害者にクリックさせます。
    *   攻撃用URL: `http://example.com/login.php?name=Guest%0d%0aSet-Cookie: SESSION_ID=ATTACKER_FIXED_ID`
    *   `%0d%0a`は改行コード（CRLF）です。

3.  **インジェクションの発生**: 脆弱なアプリケーションは、この入力をそのままヘッダに出力してしまいます。

    **本来のレスポンスヘッダ:**
    ```http
    HTTP/1.1 200 OK
    Content-Type: text/html
    Set-Cookie: name=Guest
    ```

    **注入後のレスポンスヘッダ:**
    ```http
    HTTP/1.1 200 OK
    Content-Type: text/html
    Set-Cookie: name=Guest
    Set-Cookie: SESSION_ID=ATTACKER_FIXED_ID
    ```
    これにより、被害者のブラウザには、攻撃者があらかじめ用意したセッションID (`ATTACKER_FIXED_ID`) が保存されてしまいます。

4.  **セッションハイジャック**: 被害者がそのセッションIDを使ってログインすると、攻撃者は同じセッションIDで被害者のアカウントに不正アクセス（セッションハイジャック）できるようになります。

#### 2.2. リダイレクト先の改ざん（フィッシング詐欺）

リダイレクト処理に使う`Location`ヘッダを注入し、ユーザーを悪意のある偽サイト（フィッシングサイト）へ誘導する攻撃です。

**攻撃シナリオ:**

1.  **脆弱性のあるサイト**: パラメータで指定されたURLにリダイレクトする機能があるとします。
    *   URL例: `http://example.com/redirect.php?url=http://original.com`
    *   このとき、サーバーは `Location: http://original.com` というヘッダを返します。

2.  **攻撃**: 攻撃者は、改行コードと偽の`Location`ヘッダを含むURLを作成します。
    *   攻撃用URL: `http://example.com/redirect.php?url=http://dummy.com%0d%0aLocation: http://phishing-site.com`

3.  **インジェクションの発生**: 脆弱なアプリケーションは、不正なヘッダを生成してしまいます。

    **注入後のレスポンスヘッダ:**
    ```http
    HTTP/1.1 302 Found
    Location: http://dummy.com
    Location: http://phishing-site.com
    ```
    ブラウザやサーバーの実装によっては、後から指定された`Location`ヘッダが優先され、ユーザーはフィッシングサイトにリダイレクトされてしまいます。そこで個人情報や認証情報をだまし取られる危険性があります。

#### 2.3. HTTPレスポンス分割とキャッシュ汚染

HTTPヘッダインジェクションの中でも特に深刻なのが、**HTTPレスポンス分割 (HTTP Response Splitting) 攻撃**です。 これは、攻撃者が1つのHTTPリクエストに対して、サーバーから2つ以上の不正なHTTPレスポンスを生成させる攻撃手法です。

**攻撃シナリオ:**

この攻撃は、Webサイトとユーザーの間にプロキシサーバーやキャッシュサーバーが存在する場合に、より広範囲な影響を及ぼします。

1.  **脆弱性のあるサイト**: 前述のCookie設定機能を持つサイトを例にします。

2.  **攻撃**: 攻撃者は、連続した改行コード（`%0d%0a%0d%0a`）を使い、レスポンスを完全に分割する巧妙なリクエストを送信します。

    **攻撃用URL:**
    `http://example.com/login.php?name=Guest%0d%0a%0d%0aHTTP/1.1 200 OK%0d%0aContent-Type: text/html%0d%0aContent-Length: 45%0d%0a%0d%0a<html><body><h1>PWNED!</h1></body></html>`

3.  **レスポンス分割の発生**: 脆弱なサーバーは、このリクエストを受け取ると、以下のような2つのレスポンスを生成してしまいます。

    **1つ目のレスポンス（正常だが短い）:**
    ```http
    HTTP/1.1 200 OK
    Content-Type: text/html
    Set-Cookie: name=Guest
    ```
    *(空行)*

    **2つ目のレスポンス（攻撃者が作成した偽のレスポンス）:**
    ```http
    HTTP/1.1 200 OK
    Content-Type: text/html
    Content-Length: 45

    <html><body><h1>PWNED!</h1></body></html>
    ```

4.  **キャッシュ汚染 (Web Cache Poisoning)**: キャッシュサーバーは、この2つのレスポンスを別々のものとして解釈します。そして、攻撃者が作成した2つ目の偽のレスポンスを、正規のURL（この例では`/login.php`）に対するキャッシュとして保存してしまうことがあります。

5.  **広範囲な被害**: その後、同じURLにアクセスした他のすべてのユーザーは、キャッシュサーバーからこの汚染された偽のページ（「PWNED!」と表示されるページ）を受け取ることになります。 サイトが改ざんされたのと同じ状態になり、影響が広範囲かつ永続的になるため、非常に危険です。

#### 2.4. クロスサイトスクリプティング（XSS）

HTTPレスポンス分割攻撃を応用し、レスポンスボディに任意のHTMLやJavaScriptコードを注入することで、クロスサイトスクリプティング（XSS）を引き起こすことも可能です。

**攻撃シナリオ:**

上記のキャッシュ汚染の例で、偽のレスポンスボディに`<script>alert('XSS');</script>`のような悪意のあるスクリプトを埋め込みます。この汚染されたキャッシュを他のユーザーが閲覧すると、そのユーザーのブラウザ上で不正なスクリプトが実行され、Cookieの窃取や個人情報の漏洩といった被害に繋がります。

#### 2.5. その他の脅威

*   **DoS攻撃 (Cookie Bomb攻撃)**: 巨大なサイズのCookieをユーザーに設定させることで、そのユーザーがサイトにアクセスするたびに巨大なCookieを含むリクエストを送信させ、サーバーに負荷をかけてサービス不能（DoS）状態に陥らせる攻撃です。
*   **セキュリティヘッダの無効化**: `Content-Security-Policy`などのセキュリティ関連ヘッダを無効化するようなヘッダを注入し、他の脆弱性を突きやすくする攻撃も考えられます。

---

### 3. 具体的な対策手順

HTTPヘッダインジェクションへの対策は、アプリケーション側で堅牢な実装を行うことが最も重要です。

#### 3.1. 根本的対策

##### 1. ヘッダ出力用の専用APIを利用する
最も確実で推奨される対策は、プログラミング言語やWebアプリケーションフレームワークが提供している**ヘッダ出力専用のAPIや関数を利用する**ことです。 これらのAPIは、内部で改行コードなどの危険な文字を適切に処理（無害化）してくれるように設計されています。

**【脆弱なコード例 (PHP)】**
```php
<?php
// ユーザーからの入力を直接ヘッダに設定（脆弱な例）
$url = $_GET['url'];
header("Location: " . $url); 
?>
```

**【対策済みコード例 (PHP)】**
PHPの`header()`関数は、バージョンによっては複数のヘッダを一度に出力できてしまう脆弱性がありました。しかし、近年のバージョンでは対策が施されています。より安全を期すためには、入力値の検証が不可欠です。

##### 2. 改行コードを無効化（除去またはエスケープ）する
やむを得ずユーザーの入力値をヘッダに含める必要がある場合や、専用APIが利用できない場合は、**ヘッダに出力する全ての変数から改行コード（CR, LF）を必ず除去（削除）**する必要があります。

**【対策済みコード例 (PHP)】**
```php
<?php
$name = $_GET['name'];
// 改行コード (\r, \n) を空文字に置換して除去する
$sanitized_name = str_replace(array("\r", "\n"), '', $name);
setcookie("name", $sanitized_name);
?>
```
この処理により、たとえ入力値に`%0d%0a`が含まれていても、ヘッダに出力される前に削除されるため、インジェクションは発生しません。

#### 3.2. 保険的対策

根本的対策に加え、以下の対策を多層的に講じることで、セキュリティをさらに強化できます。

##### 1. 入力値の検証（バリデーション）
そもそも、HTTPヘッダとして出力する値に、想定外の文字種や長さを許可しないように、厳格な入力値検証（バリデーション）を行うべきです。例えば、リダイレクト先のURLであれば、URLの形式として妥当か、許可されたドメインかなどをチェックします。

##### 2. WAF (Web Application Firewall) の導入
WAFを導入することで、HTTPリクエストに含まれる既知の攻撃パターン（`%0d%0a`など）を検知し、ブロックすることが可能です。 これは既存のアプリケーションに手を加えずに導入できる有効な防御策ですが、あくまで保険的な対策と位置づけ、アプリケーション自体の脆弱性を修正することが本質的な解決策となります。

---

### 4. 近年の傾向

#### フレームワークの普及による減少
近年、Ruby on Rails, Django, LaravelといったセキュアなWebアプリケーションフレームワークが広く普及しています。これらのフレームワークは、標準でHTTPヘッダインジェクション対策が施されたAPIを提供しているため、開発者が意識しなくても安全な実装が行われるケースが増えました。 その結果、IPA（情報処理推進機構）への脆弱性の届出件数としては、ピーク時に比べて減少傾向にあります。

#### 依然として残るリスク
しかし、以下のようなケースでは依然として脆弱性が作り込まれる可能性があります。
*   古いシステムや、フレームワークを使用せずに独自開発されたアプリケーション。
*   開発者がセキュリティを意識せず、フレームワークの作法から外れた危険な実装をしてしまった場合。
*   レガシーシステムとの連携部分など、特殊な要件で直接ヘッダを操作している箇所。

実際に、2010年にはウェブメール製品「Active! mail 6」、2012年にはブログシステム「Pebble」 など、様々なソフトウェアでHTTPヘッダインジェクションの脆弱性が報告されています。

#### HTTP/2, HTTP/3における変化
通信プロトコルであるHTTP/2やHTTP/3では、ヘッダの扱いがテキストベースからバイナリベースに変更されました。これにより、HTTP/1.1の時代に主流だったCRLFを使ったインジェクション攻撃は、原理的に成立しにくくなっています。

しかし、HTTP/2を実装したサーバーソフトウェア側の解釈の不備を突いた新たな攻撃手法も研究されており、プロトコルが新しくなったからといって、ヘッダインジェクションのリスクが完全になくなったわけではありません。 実際に、サーバー側の実装によっては、ヘッダ名に改行を含むことができてしまう脆弱性も発見されています。 アプリケーション開発者は、引き続き入力値の無害化という基本原則を遵守することが重要です。

---

### 5. まとめ

HTTPヘッダインジェクションは、単純な実装ミスから、サイトの改ざんや大規模な情報漏洩にまで発展しうる危険な脆弱性です。その影響範囲は、セッション固定、フィッシング詐欺、キャッシュ汚染、クロスサイトスクリプティングなど多岐にわたります。

対策の基本は、**「ユーザーからの入力を信用せず、出力する前に必ず無害化する」**というセキュリティの鉄則に尽きます。言語やフレームワークが提供する安全なAPIを利用し、入力値から改行コードを除去する処理を徹底することが、この脅威からWebアプリケーションを守るための最も確実な方法です。

近年のフレームワークの進化により脆弱性が作り込まれる機会は減っていますが、リスクがゼロになったわけではありません。開発者は常にこの攻撃手法の原理を理解し、セキュアなコーディングを心がける必要があります。
