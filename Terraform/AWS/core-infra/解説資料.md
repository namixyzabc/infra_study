# Terraform コード解説資料

## 1. はじめに

このTerraformコードは、AWS上にコンテナアプリケーションを実行するための基本的なインフラストラクチャを構築することを目的としています。

具体的には、コンテナオーケストレーションサービスである **ECS (Elastic Container Service)** のクラスターと、そのクラスターが稼働するための安全なネットワーク環境（**VPC**）を自動で構築します。

この構成は、アプリケーションのコード（コンテナイメージ）をデプロイする前段階の「土台」作りに特化しています。

## 2. ディレクトリ構成とファイルの役割

プロジェクトは、設定の起点となる「ルートモジュール」と、再利用可能な部品である「子モジュール」で構成されています。

```
D:\gemini_cli\core-infra\
├── main.tf         # (A) このプロジェクトのメインファイル
├── outputs.tf      # (B) 作成したリソースの情報を出力するファイル
├── versions.tf     # (C) Terraformとプロバイダのバージョンを定義
└── .terraform/     # Terraformが自動で管理するディレクトリ
    └── modules/
        ├── ecs_cluster/ # (D) ECSクラスタを構築するモジュール
        └── vpc/         # (E) VPC（ネットワーク）を構築するモジュール
```

*   **(A) `main.tf`**:
    *   このTerraform構成の中心となるファイルです。
    *   どのようなAWSリソースを作成するかを定義します。具体的には、後述するVPCモジュールやECSクラスタモジュールを呼び出し、必要なパラメータ（VPCのIPアドレス範囲など）を渡しています。
*   **(B) `outputs.tf`**:
    *   Terraformによって作成されたリソースの情報（例: VPCのID、サブネットのIDリスト）を、実行後に画面へ出力するための設定ファイルです。これにより、完成したインフラの情報を簡単に確認したり、他のシステムから参照したりできます。
*   **(C) `versions.tf`**:
    *   Terraform自体のバージョンや、AWSを操作するための「AWSプロバイダー」のバージョンを指定します。これにより、誰が実行しても同じ環境でインフラが構築されることを保証します。
*   **(D) `ecs_cluster` / (E) `vpc` モジュール**:
    *   Terraformのコミュニティによって作成・公開されている高品質な[公式モジュール](https://registry.terraform.io/namespaces/terraform-aws-modules)です。
    *   `vpc`モジュールはネットワーク関連の多数のリソース（VPC, サブネット, ゲートウェイ等）を、`ecs_cluster`モジュールはECS関連のリソースを、それぞれ効率的に作成するためのテンプレートです。`main.tf`はこれらのモジュールを「呼び出す」ことで、複雑なリソース定義を自身で記述することなく、ベストプラクティスに沿ったインフラを構築できます。

## 3. 構築されるAWSインフラストラクチャ

このコードを実行すると、AWSアカウントに以下のリソースが作成されます。

### 3.1. VPC (仮想ネットワーク)

`main.tf` 内の `module "vpc"` ブロックが、`.terraform/modules/vpc/` のコードを呼び出し、以下のネットワーク環境を構築します。

*   **VPC**: `10.0.0.0/16` のIPアドレス範囲を持つプライベートな仮想ネットワーク空間。
*   **サブネット**:
    *   **パブリックサブネット**: 3つ作成されます。インターネットと直接通信が可能で、後述のNATゲートウェイなどが配置されます。
    *   **プライベートサブネット**: 3つ作成されます。通常、アプリケーション本体（ECSタスク）など、外部から直接アクセスさせたくないリソースを配置するための隔離されたネットワークです。
*   **インターネットゲートウェイ (IGW)**: VPCとインターネットを接続するための出入り口です。
*   **NATゲートウェイ**: プライベートサブネット内のリソースが、外部のインターネットへアクセス（例: ソフトウェアアップデートのダウンロード）するために使用します。外部からプライベートサブネットへのアクセスは防ぎます。
*   **ルートテーブル**: サブネットごとの通信経路を制御します。
    *   パブリックサブネットは、インターネットゲートウェイへ向かうルートを持ちます。
    *   プライベートサブネットは、NATゲートウェイへ向かうルートを持ちます。

![Network Diagram](https://raw.githubusercontent.com/terraform-aws-modules/terraform-aws-vpc/master/docs/vpc-single-nat.png)
*(出典: terraform-aws-modules/vpc)*

### 3.2. ECSクラスタ

`main.tf` 内の `module "ecs_cluster"` ブロックが、`.terraform/modules/ecs_cluster/` のコードを呼び出し、コンテナ実行環境の「土台」を構築します。

*   **ECSクラスタ**: コンテナ（タスク）を管理するための論理的なグループです。この時点では、サービスやタスクはまだ実行されていません。
*   **Fargateキャパシティープロバイダー**: コンテナの実行タイプとして、サーバーの管理が不要な「Fargate」および「Fargate Spot」を利用する設定です。
*   **タスク実行ロール (IAM Role)**: ECSタスクが、コンテナイメージをECR（Elastic Container Registry）からダウンロードしたり、CloudWatch Logsにログを書き込んだりするために必要な権限です。

### 3.3. サービスディスカバリ

`main.tf`で直接定義されている `aws_service_discovery_private_dns_namespace` リソースです。

*   VPC内に `default.core-infra.local` というプライベートなDNS名前空間を作成します。
*   将来、このECSクラスタ上で複数のサービス（例: APIサーバーとフロントエンドサーバー）を起動した際に、互いのIPアドレスを直接知らなくても、`frontend.default.core-infra.local` のようなサービス名で通信できるようになります。

## 4. コードの流れとモジュール間の連携

インフラが構築される際の、コード間のデータの流れは以下のようになります。

1.  **`main.tf` が起点**:
    *   `main.tf` が `module "vpc"` を呼び出し、VPC関連リソースを作成します。
2.  **VPCの情報を他リソースが利用**:
    *   `main.tf` 内の `aws_service_discovery_private_dns_namespace` リソースは、作成するVPCを指定するために `module.vpc.vpc_id` の値（VPCモジュールの出力）を参照します。
    *   `main.tf` 内の `module "ecs_cluster"` は、サービスディスカバリの名前空間を指定するために `aws_service_discovery_private_dns_namespace.this.arn` の値を参照します。
3.  **`outputs.tf` で最終結果を出力**:
    *   `outputs.tf` は、`module "vpc"` や `module "ecs_cluster"` が出力したリソースID、ARNなどをまとめて、Terraform実行後の画面に表示します。

このように、各リソースやモジュールは、他のモジュールの「出力（output）」を自身の「入力（variable）」として受け取ることで、互いに依存関係を持ちながら正しい順序で構築されていきます。

## 5. まとめ

このTerraformプロジェクトは、再利用性の高い公開モジュールを効果的に活用し、AWS上でスケーラブルかつ安全なコンテナ基盤（ネットワークとECSクラスタ）を構築するための、堅牢なテンプレートです。

次のステップは、この基盤の上に、実際に動かしたいアプリケーションのコンテナイメージを「ECSサービス」として定義し、デプロイすることになります。
