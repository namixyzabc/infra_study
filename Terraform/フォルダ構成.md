### 概要

業務基幹システムをTerraformで構築する際には、**環境の分離**、**コードの再利用性**、**保守性**、そして**拡張性**が極めて重要です。これを実現するため、構成を「**モジュール（再利用可能な部品）**」と「**環境（パラメータを定義し、モジュールを呼び出す実体）**」に分離するアプローチがベストプラクティスとされています。

---

### 推奨されるフォルダ構成例（エンタープライズ向け）

小規模から大規模なプロジェクトまで対応可能な、汎用性と拡張性の高いフォルダ構成例です。

```
.
├── environments/ (または envs/)
│   ├── development/ (または dev/)
│   │   └── japaneast/
│   │       ├── platform/               # 共有基盤 (VNet, KeyVault等)
│   │       │   ├── main.tf
│   │       │   ├── variables.tf
│   │       │   ├── terraform.tfvars
│   │       │   ├── providers.tf
│   │       │   └── backend.hcl
│   │       └── workloads/
│   │           └── core-system/        # 業務システム
│   │               ├── main.tf
│   │               ├── variables.tf
│   │               ├── terraform.tfvars
│   │               ├── providers.tf
│   │               └── backend.hcl
│   ├── staging/ (または stg/)
│   │   └─ ... (developmentと同様の構成)
│   └── production/ (または prod/)
│       └─ ... (developmentと同様の構成)
│
├── modules/
│   ├── network/
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   └── outputs.tf
│   ├── vm-windows/
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   └── outputs.tf
│   ├── vm-linux/
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   └── outputs.tf
│   ├── security/
│   ├── storage/
│   └── database/
│
├── templates/
│   ├── cloud-init/                    # Linux VMの初期化スクリプト (YAML)
│   └── powershell/                    # Windows VMの初期化スクリプト (.ps1)
│
├── scripts/
│   ├── plan.sh                        # terraform planを定型化するスクリプト
│   └── apply.sh                       # terraform applyを定型化するスクリプト
│
├── policies/
│   ├── sentinel.hcl                   # Terraform Cloud/Enterprise用のポリシー
│   └── custom-policy.json             # Azure Policyの定義ファイル
│
├── docs/
│   ├── README.md
│   └── ARCHITECTURE.md
│
├── tests/
│   └── ...                            # Terratest等を用いたモジュールの単体テスト
│
├── .gitignore
├── versions.tf                        # プロバイダやTerraformのバージョンを定義
└── .terraform.lock.hcl                # プロバイダのバージョンをロック
```

---

### 各ディレクトリとファイルの役割

#### 1. `environments` (または `envs`) ディレクトリ
各環境（開発、ステージング、本番）ごとの設定を管理します。環境をディレクトリで分離することで、設定の独立性を保ち、誤操作のリスクを低減します。
さらに、リージョン（`japaneast`など）や、`platform`（共有基盤）、`workloads`（業務アプリケーション）といった**レイヤー**でディレクトリを分けることで、状態ファイル（`.tfstate`）も分割され、変更による影響範囲（Blast Radius）を最小限に抑えることができます。

*   **`main.tf`**: その環境・レイヤーで利用するリソースを定義します。主に`modules`ディレクトリ内のモジュールを呼び出し、環境固有のパラメータ（例: VMのサイズや台数）を渡すことに徹します。
*   **`variables.tf`**: `main.tf`で使用する変数を定義します。型や説明を記述することで、コードの可読性が向上します。
*   **`terraform.tfvars`**: `variables.tf`で定義した変数に、具体的な値を設定します。**パスワードなどの機密情報は含めず**、Azure Key Vaultなどを参照するようにします。
*   **`backend.hcl` / `backend.tf`**: Terraformの状態ファイル（`.tfstate`）の保存場所（バックエンド）を定義します。チーム開発では、Azure Blob Storageなどのリモートバックエンドを指定し、状態ファイルを一元管理することで安全な共同作業を実現します。
*   **`providers.tf` / `versions.tf`**: Terraform本体や、Azureプロバイダ（`azurerm`）のバージョンを指定します。これにより、誰が実行しても同じバージョンで動作することが保証されます。

#### 2. `modules` ディレクトリ
再利用可能なインフラ構成を「モジュール」としてまとめて管理します。ネットワーク、VM、セキュリティグループといった機能単位でモジュールを作成することで、コードの重複をなくし、保守性を高めます。

*   **`network/`**: 仮想ネットワーク（VNet）、サブネットなど、基本的なネットワーク関連リソースをまとめたモジュールです。
*   **`vm-windows/`**: WindowsサーバーVMを構築するためのモジュールです。OSイメージの指定、ディスク構成、ドメイン参加、WinRM有効化、カスタムスクリプト実行など、Windows固有の構成をまとめます。
*   **`vm-linux/`**: LinuxサーバーVMを構築するためのモジュールです。OSイメージの指定、SSHキーの設定、`cloud-init`を使った初期設定など、Linux固有の構成をまとめます。
*   **モジュール内のファイル**:
    *   **`main.tf`**: モジュールが作成するリソースを定義します。
    *   **`variables.tf`**: モジュールが受け取る入力パラメータを定義します。
    *   **`outputs.tf`**: モジュールの実行結果（作成したリソースのIDなど）を外部に出力するために定義します。

#### 3. `templates` ディレクトリ
VMの初期化に使うスクリプトファイル（例: `cloud-init`のYAMLファイルやPowerShellスクリプト）を一元管理します。コードとスクリプトを分離することで、管理やレビューが容易になります。

#### 4. その他のディレクトリ
*   **`scripts/`**: `terraform plan`や`apply`といった定型的なコマンドをラップするシェルスクリプトなどを配置し、操作を標準化します。
*   **`policies/`**: コードの品質やセキュリティを担保するためのポリシーファイル（`tflint`、`tfsec`、`Sentinel`など）を管理します。
*   **`docs/`**: プロジェクトの構成図やセットアップ手順などのドキュメントを格納します。
*   **`tests/`**: モジュールが意図通りに動作するかを自動テストするためのコード（Terratestなど）を配置します。

---

### ベストプラクティスのポイント

この構成が推奨される理由と、運用上の重要なポイントは以下の通りです。

| 項目 | 推奨内容と目的 |
| :--- | :--- |
| **環境分離** | `environments/` で環境ごとのパラメータ (`.tfvars`) と状態ファイル (`.tfstate`) を完全に分離し、事故を防止する。 |
| **モジュール化** | `modules/` でインフラ構成を部品化し、コードの再利用性を高め、重複を排除する。 |
| **状態管理** | `backend "azurerm"` を使用し、状態ファイルをAzure Storageに安全に一元管理する。 |
| **レイヤー分割** | 状態ファイルを共有基盤 (`platform`) と業務 (`workloads`) などで分割し、変更の影響範囲を限定する。 |
| **シークレット管理** | パスワード等の機密情報は `terraform.tfvars` に直書きせず、Azure Key Vaultからデータソースとして動的に読み込む。 |
| **バージョン固定** | `versions.tf` と `.terraform.lock.hcl` でTerraformとプロバイダのバージョンを固定し、実行環境による差異をなくす（再現性の確保）。 |
| **命名規則・タグ付け** | `locals` や `naming` モジュールでリソースの命名規則を統一し、コスト管理やオーナーシップを明確にするためのタグを全リソースに付与する。 |
| **CI/CD連携** | `fmt`, `validate`, `tflint`, `tfsec` (静的解析), `plan` をCI/CDパイプラインに組み込み、コードの品質とデプロイの安全性を自動的に確保する。 |
| **OS固有設定の吸収** | `vm-windows` と `vm-linux` モジュールでOSごとの差異を吸収し、環境側からはシンプルに呼び出せるようにする。 |

このフォルダ構成を採用することで、保守性、拡張性、安全性が高く、チームでの開発にも適したスケーラブルなIaC（Infrastructure as Code）環境を実現できます。

---

### 統合における矛盾点について

ご提示いただいた3つの回答には、プロジェクトの構成思想に一部違い（矛盾）が見られました。

*   **矛盾点**: **ルートモジュール（`main.tf`などが置かれ、`terraform apply`を実行する起点となる場所）をどこに配置するか**という点です。

    *   **パターンA（本稿で採用した構成）**: 各環境ディレクトリ（例: `environments/production/workloads/core-system/`）がそれぞれ独立したルートモジュールとなる構成です。このアプローチは、環境やレイヤーごとの独立性が非常に高く、影響範囲を厳密に分離できるため、大規模システムで好まれます。（主に文章1と3の思想）

    *   **パターンB**: プロジェクトの最上位に`root/`のような共通のルートモジュールを一つだけ配置し、`environments`ディレクトリには変数ファイル（`terraform.tfvars`など）のみを置いて、コマンド実行時に`-var-file`オプションで環境を切り替える構成です。（主に文章2の思想）

どちらのアプローチも有効ですが、本稿ではより疎結合で影響範囲を限定しやすい**パターンA**をベースに、各回答のベストプラクティスを網羅的に統合しました。
