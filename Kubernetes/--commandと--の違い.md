**🌟kubectl run testpod \--image=alpine \--restart=Never \--command \-- sh \-c "sleep 100"**

**・–commandを使う（コンテナのイメージのコマンドを上書きする）**

**・--を使う**

**・コマンド本体をシングルクォートまたはダブルクォートで囲う（ダブルクォートは、コマンド全体を1つの文字列として`sh`に渡すために使用されます。）**

**・デフォルトでは `kubectl run` は Pod ではなく Deployment を作成するため`--restart=Never` を使う**

**・`-c`: `sh`のオプションで、続く文字列をコマンドとして実行することを指示します。**

**🌟kubectl exec \-it test \-c app – sh**

**`kubectl` コマンド自体はシェル上で動作するコマンドラインツールなので、クォーテーション（引用符）の基本的な扱いは、シェルのルールに従います。**  
**つまり、シングルクォーテーションとダブルクォーテーションの違いは、`kubectl` 固有のものではなく、シェルの動作そのものです。**

---

### **主なポイント**

1. **シングルクォーテーション `'...'` を使った場合**  
   * **中の内容がそのままの文字列として渡されます。**  
   * **変数展開やコマンド置換が一切行われません。**

**例： JSONPath など、シェルの解釈を避けたい場合に便利です。**  
**sh**  
**コピーする編集する**  
**`# JSONPath を使って Pod 名一覧を取得する例`**

**`kubectl get pods -o jsonpath='{.items[*].metadata.name}'`**

* **上記の例では、`{.items[*].metadata.name}` がそのまま `kubectl` に渡され、シェルが解釈しないので安心です。**  
2. **ダブルクォーテーション `"..."` を使った場合**  
   * **中の変数やコマンドがシェルで展開されます。**  
   * **変数の値やコマンドの結果を組み込みたい場合に使用します。**

**例： ラベルセレクタに変数を使う場合**  
**sh**  
**コピーする編集する**  
**`APP_NAME="nginx"`**

**`kubectl get pods -l "app=${APP_NAME}"`**

* **この例では、`"app=${APP_NAME}"` 内の `${APP_NAME}` がシェルによって展開され、実際に `app=nginx` という引数が `kubectl` に渡されます。**

**ENTRYPOINTとは何か？**

ENTRYPOINTは、コンテナが起動したときに「必ず実行されるコマンド」を指定するための仕組みです。　コンテナの主要な目的（プロセス）を定義するものと考えてください。

* **Dockerfileでの定義:** Dockerfile内で `ENTRYPOINT` 命令を使って定義します。  
* **Kubernetesでの扱い:** Kubernetesでは、Podの定義内で `command` フィールドを使って、Dockerfileで定義されたENTRYPOINTを上書きしたり、別のコマンドを指定したりできます。

`kubectl run` コマンドでは、Pod 内のコンテナで実行するプログラム（すなわちコンテナのエントリポイント）をどう設定するか、という点でいくつかの注意点があります。主な違いは、**`--command` オプションの有無**と、**コマンドや引数の記述方法**にあります。

Kubernetes の Pod 仕様では、コンテナの実行は「**command**（エントリポイント）と **args**（引数）」の 2 つのフィールドで指定されます。

* **`--command` を使わない場合**  
  コマンドとして渡したものは、コンテナイメージの\*\*デフォルトの command（通常は Dockerfile の ENTRYPOINT または CMD）\*\*に対する引数（args）として設定されます。  
* **`--command` を使う場合**  
  渡したものがコンテナの**command（エントリポイント）そのもの**として上書きされ、args は設定されません。  
  **`--`（ダブルハイフン）の重要性**  
  コマンド部分と kubectl のオプション部分を正しく区切るため、必ず `--` を入れて区切る必要があります。  
  **コマンドや引数のクオートの使い方**  
  **クォートの使用: シェルスクリプトや複雑なコマンドを実行する場合は、コマンド全体をシングルクォートまたはダブルクォートで囲むことで、シェルによる予期しない解釈を防ぎます。**




### **1\. コマンド①**

sh

`kubectl run testpod --image=alpine -- sh -c 'sleep 100'`

* **説明**:  
  `--command` オプションが使われていないので、`--` 以降の `sh -c 'sleep 100'` は **args** として扱われます。

**結果**:  
Alpine イメージの Dockerfile では通常 `CMD ["/bin/sh"]` が指定されているため、コンテナは実際には

`command: ["/bin/sh"]`  
`args: ["sh", "-c", "sleep 100"]`

* となります。

**問題点**:  
すでに `/bin/sh` が実行されるため、さらに最初の引数として `"sh"` が渡されると、意図した `sh -c 'sleep 100'` ではなく、  
bash

`/bin/sh "sh" "-c" "sleep 100"`

* という形になってしまい、余分な `"sh"` が入るために正しく動作しない可能性があります。

---

### **2\. コマンド②**

sh

`kubectl run testpod --image=alpine --command -- sh -c 'sleep 100'`

* **説明**:  
  `--command` を指定しているので、`--` 以降の内容がコンテナの **command（エントリポイント）** として設定されます。

**結果**:  
Pod のコンテナ定義は次のようになります。

`command: ["sh", "-c", "sleep 100"]`  
`args: []`

* これにより、意図通り `sh -c 'sleep 100'` が実行されます。  
* **ポイント**:  
  正しく **command** を上書きするため、余計な引数のずれがなく、シンプルに動作します。

---

### **3\. コマンド③**

sh

`kubectl run testpod --image=alpine --command -- sh -c sleep 100`

* **説明**:  
  コマンド②と同様に `--command` を指定しているので、すべてのトークンが **command** として扱われます。

**結果**:  
渡されるトークンは分割されて

`command: ["sh", "-c", "sleep", "100"]`

* となります。

**問題点**:  
POSIX の `sh -c` は書式として  
nginx

`sh -c "command_string" [argument...]`

* を期待します。  
  コマンド②では `"sleep 100"` という 1 つの文字列が渡されるのに対し、コマンド③では `"sleep"` と `"100"` に分かれてしまいます。  
  その結果、`sh` は `"sleep"` を実行するコマンド文字列として認識し、 `"100"` は `$0`（またはその他のパラメータ）として扱われ、意図通りに `sleep 100` が動作しない可能性があります。

---

### **4\. コマンド④**

sh

`kubectl run testpod --image=alpine --command sh -c 'sleep 100'`

* **説明**:  
  `--command` は指定されていますが、コマンド部分と kubectl のオプション部分の区切りを示す `--` が省略されています。  
* **結果・問題点**:  
  CLI のパーサーは、`sh` や `-c` を kubectl の別のオプションや引数と誤認する可能性があり、正しく解釈されずにエラーになったり、意図しない動作になる恐れがあります。  
* **注意**:  
  コマンド部分を渡す際は、**必ず `--` を使ってオプションとコマンドの境界を明示する**必要があります。

---

### **5\. コマンド⑤**

sh

`kubectl run testpod --command image=alpine -- sleep 100`

* **説明**:  
  ここでは `--command` は指定されていますが、イメージ指定の部分が誤っています。  
* **問題点**:  
  正しくは `--image=alpine` と記述すべきところが、`image=alpine`（前に `--` がない）となっているため、kubectl はこれをオプションとして認識せず、コマンドの一部または位置引数として扱ってしまいます。  
  結果、指定したイメージが認識されず、Pod の作成に失敗するか、予期しない動作になります。

---

### **まとめ**

* **`--command` の有無**  
  * **使わない場合**: 渡した文字列は **args** にセットされ、イメージのデフォルト command（例: `/bin/sh`）がそのまま使われるため、余計な引数が入ってしまうリスクがあります。  
  * **使う場合**: 渡した文字列が **command** として設定され、正確に実行されます。  
* **`--`（ダブルハイフン）の重要性**  
  コマンド部分と kubectl のオプション部分を正しく区切るため、必ず `--` を入れて区切る必要があります。  
* **コマンドや引数のクオートの使い方**  
  シェルの解釈により、スペースを含むコマンド文字列は適切にクオートして 1 つの引数として渡す必要があります。

以上の点を踏まえると、**コマンド②**

sh

`kubectl run testpod --image=alpine --command -- sh -c 'sleep 100'`

が最も意図通り（すなわち、コンテナで `sh -c 'sleep 100'` を実行する）に動作する正しい書き方となります。
